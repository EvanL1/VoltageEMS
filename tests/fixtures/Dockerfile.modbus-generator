# Modbus Data Generator
FROM python:3.11-slim

RUN apt-get update && apt-get install -y \
    netcat \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install Python dependencies
RUN pip install --no-cache-dir \
    pymodbus \
    asyncio \
    numpy

# Create Modbus data generator script
RUN cat > /app/generate_modbus_data.py << 'EOF'
#!/usr/bin/env python3
"""
Modbus Data Generator for VoltageEMS Testing
Generates realistic telemetry data for Modbus simulators
"""

import asyncio
import random
import time
import argparse
import json
from datetime import datetime
import logging
from pymodbus.client.tcp import ModbusTcpClient
import numpy as np

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ModbusDataGenerator:
    def __init__(self, hosts=['modbus-simulator-1', 'modbus-simulator-2'], port=5020):
        self.hosts = hosts
        self.port = port
        self.clients = {}
        self.running = False
        
        # Simulation parameters
        self.base_values = {
            'temperature': 25.0,
            'pressure': 1013.25,
            'voltage': 220.0,
            'current': 10.0,
            'power': 2200.0,
            'frequency': 50.0
        }
        
        # Value ranges for realistic variation
        self.value_ranges = {
            'temperature': (20.0, 30.0),
            'pressure': (1010.0, 1020.0), 
            'voltage': (210.0, 230.0),
            'current': (8.0, 12.0),
            'power': (2000.0, 2400.0),
            'frequency': (49.5, 50.5)
        }

    async def connect_to_simulators(self):
        """Connect to all Modbus simulators"""
        logger.info("Connecting to Modbus simulators...")
        
        for host in self.hosts:
            try:
                client = ModbusTcpClient(host, port=self.port)
                if client.connect():
                    self.clients[host] = client
                    logger.info(f"Connected to {host}:{self.port}")
                else:
                    logger.error(f"Failed to connect to {host}:{self.port}")
            except Exception as e:
                logger.error(f"Error connecting to {host}: {e}")

    def generate_realistic_values(self):
        """Generate realistic values with trends and noise"""
        values = {}
        
        # Add time-based trends
        hour = datetime.now().hour
        day_factor = np.sin(2 * np.pi * hour / 24)  # Daily cycle
        
        for param, base_value in self.base_values.items():
            min_val, max_val = self.value_ranges[param]
            
            # Base variation
            variation = random.uniform(-0.1, 0.1) * base_value
            
            # Daily trend (temperature higher during day, power consumption varies)
            if param == 'temperature':
                trend = day_factor * 5.0  # ±5°C daily variation
            elif param == 'power':
                trend = day_factor * 200.0  # ±200W daily variation
            else:
                trend = day_factor * 0.05 * base_value
            
            # Random noise
            noise = random.gauss(0, 0.02 * base_value)
            
            # Calculate final value
            final_value = base_value + variation + trend + noise
            values[param] = max(min_val, min(max_val, final_value))
        
        return values

    def generate_alarm_conditions(self):
        """Occasionally generate values that trigger alarms"""
        if random.random() < 0.05:  # 5% chance of alarm condition
            alarm_type = random.choice(['temperature', 'pressure', 'voltage'])
            
            if alarm_type == 'temperature':
                return {'temperature': random.uniform(35.0, 40.0)}
            elif alarm_type == 'pressure':
                return {'pressure': random.uniform(1025.0, 1030.0)}
            elif alarm_type == 'voltage':
                return {'voltage': random.uniform(190.0, 200.0)}
        
        return {}

    async def write_data_to_simulator(self, host, client, values):
        """Write data to a specific Modbus simulator"""
        try:
            # Map values to Modbus registers
            # Assuming holding registers starting at address 0
            registers = [
                int(values['temperature'] * 100),      # Register 0: Temperature * 100
                int(values['pressure'] * 10),          # Register 1: Pressure * 10
                int(values['voltage'] * 10),           # Register 2: Voltage * 10
                int(values['current'] * 100),          # Register 3: Current * 100
                int(values['power']),                  # Register 4: Power
                int(values['frequency'] * 100),        # Register 5: Frequency * 100
                int(random.choice([0, 1])),           # Register 6: Status bit
                int(datetime.now().timestamp()) % 65535, # Register 7: Timestamp (lower 16 bits)
            ]
            
            # Write to holding registers
            result = client.write_registers(0, registers)
            if result.isError():
                logger.error(f"Error writing to {host}: {result}")
            else:
                logger.debug(f"Data written to {host}: temp={values['temperature']:.1f}°C, "
                           f"pressure={values['pressure']:.1f}hPa, voltage={values['voltage']:.1f}V")
            
        except Exception as e:
            logger.error(f"Error writing data to {host}: {e}")

    async def generate_data_loop(self, duration_seconds=3600):
        """Main data generation loop"""
        logger.info(f"Starting data generation for {duration_seconds} seconds...")
        
        start_time = time.time()
        self.running = True
        
        while self.running and (time.time() - start_time) < duration_seconds:
            # Generate base values
            base_values = self.generate_realistic_values()
            
            # Check for alarm conditions
            alarm_overrides = self.generate_alarm_conditions()
            
            # Apply alarm overrides if any
            values = {**base_values, **alarm_overrides}
            
            # Write data to all connected simulators
            for host, client in self.clients.items():
                if client.is_socket_open():
                    await self.write_data_to_simulator(host, client, values)
                else:
                    logger.warning(f"Connection to {host} is closed, attempting reconnect...")
                    if client.connect():
                        logger.info(f"Reconnected to {host}")
                    else:
                        logger.error(f"Failed to reconnect to {host}")
            
            # Log current values periodically
            if int(time.time()) % 60 == 0:  # Every minute
                logger.info(f"Current values: {json.dumps({k: round(v, 2) for k, v in values.items()}, indent=2)}")
            
            # Wait before next update
            await asyncio.sleep(1.0)  # 1 second update rate
        
        logger.info("Data generation completed")

    def cleanup(self):
        """Clean up connections"""
        logger.info("Cleaning up connections...")
        for host, client in self.clients.items():
            try:
                client.close()
                logger.info(f"Disconnected from {host}")
            except:
                pass

    async def run(self, duration_seconds=3600):
        """Run the data generator"""
        try:
            await self.connect_to_simulators()
            
            if not self.clients:
                logger.error("No Modbus simulators connected, exiting...")
                return
            
            await self.generate_data_loop(duration_seconds)
            
        except KeyboardInterrupt:
            logger.info("Received interrupt signal, stopping...")
            self.running = False
            
        except Exception as e:
            logger.error(f"Data generation error: {e}")
            
        finally:
            self.cleanup()

async def main():
    parser = argparse.ArgumentParser(description='Modbus Data Generator for VoltageEMS Testing')
    parser.add_argument('--duration', type=int, default=3600, 
                       help='Duration to run in seconds (default: 3600)')
    parser.add_argument('--hosts', nargs='+', default=['modbus-simulator-1', 'modbus-simulator-2'],
                       help='Modbus simulator hosts')
    parser.add_argument('--port', type=int, default=5020,
                       help='Modbus port (default: 5020)')
    
    args = parser.parse_args()
    
    generator = ModbusDataGenerator(hosts=args.hosts, port=args.port)
    await generator.run(duration_seconds=args.duration)

if __name__ == "__main__":
    asyncio.run(main())
EOF

RUN chmod +x /app/generate_modbus_data.py

CMD ["python", "/app/generate_modbus_data.py"]