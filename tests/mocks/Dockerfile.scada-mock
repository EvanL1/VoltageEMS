# Mock SCADA System
FROM python:3.11-slim

WORKDIR /app

RUN pip install --no-cache-dir \
    fastapi \
    uvicorn \
    pydantic \
    websockets

# Create mock SCADA system
RUN cat > /app/mock_scada_system.py << 'EOF'
#!/usr/bin/env python3
"""
Mock SCADA System for VoltageEMS Testing
Simulates external SCADA system behavior
"""

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from pydantic import BaseModel
import json
import logging
import asyncio
import random
from datetime import datetime
from typing import List, Optional, Dict, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Mock SCADA System", version="1.0.0")

# Data models
class ControlCommand(BaseModel):
    device_id: str
    command: str
    parameters: Dict[str, Any] = {}
    priority: int = 1

class ControlResponse(BaseModel):
    command_id: str
    status: str
    message: str
    timestamp: str
    execution_time_ms: Optional[int] = None

class DeviceStatus(BaseModel):
    device_id: str
    online: bool
    last_seen: str
    status: str
    values: Dict[str, Any] = {}

# In-memory storage
connected_devices = {}
command_history = []
active_websockets = []

# Simulated device data
MOCK_DEVICES = {
    "device_001": {"type": "transformer", "location": "substation_a"},
    "device_002": {"type": "generator", "location": "powerplant_1"},
    "device_003": {"type": "switch", "location": "distribution_center"},
    "device_004": {"type": "sensor", "location": "substation_b"},
}

@app.on_startup
async def startup_event():
    """Initialize mock devices on startup"""
    for device_id, info in MOCK_DEVICES.items():
        connected_devices[device_id] = {
            "id": device_id,
            "type": info["type"],
            "location": info["location"],
            "online": True,
            "last_seen": datetime.now().isoformat(),
            "status": "normal",
            "values": generate_device_values(info["type"])
        }
    
    # Start background task to update device values
    asyncio.create_task(update_device_values())

def generate_device_values(device_type: str) -> Dict[str, Any]:
    """Generate realistic values based on device type"""
    base_values = {
        "transformer": {
            "voltage_primary": random.uniform(10000, 11000),
            "voltage_secondary": random.uniform(400, 440),
            "current": random.uniform(100, 150),
            "temperature": random.uniform(40, 60),
            "load_percent": random.uniform(60, 90)
        },
        "generator": {
            "voltage": random.uniform(220, 240),
            "current": random.uniform(50, 100),
            "frequency": random.uniform(49.8, 50.2),
            "power_output": random.uniform(1000, 2000),
            "fuel_level": random.uniform(70, 100)
        },
        "switch": {
            "position": random.choice(["open", "closed"]),
            "contact_status": random.choice(["good", "normal"]),
            "operation_count": random.randint(1000, 5000)
        },
        "sensor": {
            "temperature": random.uniform(20, 30),
            "humidity": random.uniform(40, 70),
            "pressure": random.uniform(1000, 1020)
        }
    }
    return base_values.get(device_type, {})

async def update_device_values():
    """Background task to continuously update device values"""
    while True:
        for device_id, device in connected_devices.items():
            # Simulate occasional offline devices
            if random.random() < 0.02:  # 2% chance of going offline
                device["online"] = False
                device["status"] = "offline"
            elif not device["online"] and random.random() < 0.1:  # 10% chance of coming back online
                device["online"] = True
                device["status"] = "normal"
            
            if device["online"]:
                device["values"] = generate_device_values(device["type"])
                device["last_seen"] = datetime.now().isoformat()
                
                # Simulate alarm conditions occasionally
                if random.random() < 0.05:  # 5% chance of alarm
                    device["status"] = "alarm"
                elif device["status"] == "alarm" and random.random() < 0.3:  # 30% chance of clearing alarm
                    device["status"] = "normal"
        
        # Broadcast updates to connected WebSocket clients
        if active_websockets:
            update_message = {
                "type": "device_update",
                "timestamp": datetime.now().isoformat(),
                "devices": list(connected_devices.values())
            }
            
            # Send to all connected clients
            disconnected = []
            for ws in active_websockets:
                try:
                    await ws.send_text(json.dumps(update_message))
                except:
                    disconnected.append(ws)
            
            # Remove disconnected clients
            for ws in disconnected:
                active_websockets.remove(ws)
        
        await asyncio.sleep(5)  # Update every 5 seconds

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "mock-scada",
        "timestamp": datetime.now().isoformat(),
        "connected_devices": len([d for d in connected_devices.values() if d["online"]])
    }

@app.get("/devices")
async def list_devices():
    """List all devices"""
    return {
        "devices": list(connected_devices.values()),
        "total": len(connected_devices),
        "online": len([d for d in connected_devices.values() if d["online"]])
    }

@app.get("/devices/{device_id}")
async def get_device(device_id: str):
    """Get specific device information"""
    if device_id not in connected_devices:
        return {"error": "Device not found"}, 404
    
    return connected_devices[device_id]

@app.post("/commands", response_model=ControlResponse)
async def execute_command(command: ControlCommand):
    """Execute control command on device"""
    import time
    start_time = time.time()
    
    command_id = f"cmd_{int(time.time() * 1000)}"
    
    # Simulate command processing
    await asyncio.sleep(random.uniform(0.1, 0.5))
    
    # Check if device exists and is online
    if command.device_id not in connected_devices:
        response = ControlResponse(
            command_id=command_id,
            status="failed",
            message="Device not found",
            timestamp=datetime.now().isoformat()
        )
    elif not connected_devices[command.device_id]["online"]:
        response = ControlResponse(
            command_id=command_id,
            status="failed", 
            message="Device is offline",
            timestamp=datetime.now().isoformat()
        )
    else:
        # Simulate command execution
        success_rate = 0.95  # 95% success rate
        if random.random() < success_rate:
            # Update device state based on command
            device = connected_devices[command.device_id]
            if command.command == "switch_open" and device["type"] == "switch":
                device["values"]["position"] = "open"
            elif command.command == "switch_close" and device["type"] == "switch":
                device["values"]["position"] = "closed"
            
            response = ControlResponse(
                command_id=command_id,
                status="success",
                message="Command executed successfully",
                timestamp=datetime.now().isoformat(),
                execution_time_ms=int((time.time() - start_time) * 1000)
            )
        else:
            response = ControlResponse(
                command_id=command_id,
                status="failed",
                message="Command execution failed",
                timestamp=datetime.now().isoformat()
            )
    
    # Store command in history
    command_record = {
        "id": command_id,
        "device_id": command.device_id,
        "command": command.command,
        "parameters": command.parameters,
        "priority": command.priority,
        "status": response.status,
        "timestamp": response.timestamp,
        "execution_time_ms": response.execution_time_ms
    }
    command_history.append(command_record)
    
    logger.info(f"Command executed: {command_id} - {command.command} on {command.device_id} - {response.status}")
    
    return response

@app.get("/commands/history")
async def get_command_history(limit: int = 100):
    """Get command execution history"""
    return {
        "commands": command_history[-limit:],
        "total": len(command_history)
    }

@app.get("/commands/{command_id}")
async def get_command_status(command_id: str):
    """Get status of specific command"""
    for command in command_history:
        if command["id"] == command_id:
            return command
    return {"error": "Command not found"}, 404

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time device updates"""
    await websocket.accept()
    active_websockets.append(websocket)
    
    logger.info("WebSocket client connected")
    
    # Send initial device status
    initial_message = {
        "type": "initial_status",
        "timestamp": datetime.now().isoformat(),
        "devices": list(connected_devices.values())
    }
    
    try:
        await websocket.send_text(json.dumps(initial_message))
        
        # Keep connection alive
        while True:
            # Wait for client messages (if any)
            try:
                data = await websocket.receive_text()
                # Echo back any received messages
                await websocket.send_text(f"Echo: {data}")
            except WebSocketDisconnect:
                break
                
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
    finally:
        if websocket in active_websockets:
            active_websockets.remove(websocket)
        logger.info("WebSocket client disconnected")

@app.get("/stats")
async def get_stats():
    """Get system statistics"""
    return {
        "total_devices": len(connected_devices),
        "online_devices": len([d for d in connected_devices.values() if d["online"]]),
        "total_commands": len(command_history),
        "successful_commands": len([c for c in command_history if c["status"] == "success"]),
        "active_websockets": len(active_websockets),
        "uptime": time.time()
    }

@app.post("/simulate/alarm/{device_id}")
async def simulate_alarm(device_id: str):
    """Simulate alarm condition on device"""
    if device_id not in connected_devices:
        return {"error": "Device not found"}, 404
    
    connected_devices[device_id]["status"] = "alarm"
    logger.info(f"Simulated alarm on device {device_id}")
    
    return {"message": f"Alarm simulated on device {device_id}"}

@app.post("/simulate/offline/{device_id}")
async def simulate_offline(device_id: str):
    """Simulate device going offline"""
    if device_id not in connected_devices:
        return {"error": "Device not found"}, 404
    
    connected_devices[device_id]["online"] = False
    connected_devices[device_id]["status"] = "offline"
    logger.info(f"Simulated offline status for device {device_id}")
    
    return {"message": f"Device {device_id} simulated offline"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8080)
EOF

RUN chmod +x /app/mock_scada_system.py

EXPOSE 8080

CMD ["python", "/app/mock_scada_system.py"]