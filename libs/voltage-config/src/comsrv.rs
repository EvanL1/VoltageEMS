//! Comsrv service configuration structures

use crate::common::{ApiConfig, BaseServiceConfig, LoggingConfig, RedisConfig};
use serde::de::{self, Deserializer};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use voltage_schema_macro::Schema;

#[cfg(feature = "schema")]
use schemars::JsonSchema;

// ============================================================================
// Custom Deserializers
// ============================================================================

/// Custom deserializer for boolean fields that supports multiple input formats
///
/// Supports native JSON booleans, integers, and string values:
/// - JSON boolean: true, false
/// - JSON integer: 0 (false), 1 (true)
/// - CSV string: "1"/"0", "true"/"false", "yes"/"no" (case-insensitive)
fn deserialize_bool_flexible<'de, D>(deserializer: D) -> Result<bool, D::Error>
where
    D: Deserializer<'de>,
{
    use serde::Deserialize;

    #[derive(Deserialize)]
    #[serde(untagged)]
    enum BoolOrStringOrInt {
        Bool(bool),
        Int(i64),
        String(String),
    }

    match BoolOrStringOrInt::deserialize(deserializer)? {
        BoolOrStringOrInt::Bool(b) => Ok(b),
        BoolOrStringOrInt::Int(i) => match i {
            0 => Ok(false),
            1 => Ok(true),
            _ => Err(de::Error::custom(format!(
                "Invalid integer value {}, expected 0 or 1",
                i
            ))),
        },
        BoolOrStringOrInt::String(s) => match s.to_lowercase().trim() {
            "1" | "true" | "yes" => Ok(true),
            "0" | "false" | "no" | "" => Ok(false),
            other => Err(de::Error::custom(format!(
                "Invalid boolean value '{}', expected: 1/0, true/false, yes/no, or boolean",
                other
            ))),
        },
    }
}

/// Custom deserializer for u8 fields that treats empty strings as 0
///
/// Allows CSV files to have empty bit_position values which default to 0
/// Supports: numeric strings or empty string
fn deserialize_u8_default_zero<'de, D>(deserializer: D) -> Result<u8, D::Error>
where
    D: Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    let trimmed = s.trim();
    if trimmed.is_empty() {
        Ok(0)
    } else {
        trimmed.parse::<u8>().map_err(de::Error::custom)
    }
}

/// Default API configuration for comsrv (port 6001)
fn default_comsrv_api() -> ApiConfig {
    ApiConfig {
        host: "0.0.0.0".to_string(),
        port: 6001,
    }
}

/// Comsrv service configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ComsrvConfig {
    /// Base service configuration
    #[serde(flatten, default)]
    pub service: BaseServiceConfig,

    /// API configuration (has default value)
    #[serde(default = "default_comsrv_api")]
    pub api: ApiConfig,

    /// Redis configuration
    #[serde(default)]
    pub redis: RedisConfig,

    /// Logging configuration
    #[serde(default)]
    pub logging: LoggingConfig,

    /// Channel configurations
    #[serde(default)]
    pub channels: Vec<ChannelConfig>,
}

// ============================================================================
// Database Schema Definitions (Generated by voltage-schema-macro)
// ============================================================================

/// Service configuration table record
/// Maps to ComsrvConfig for service-level settings
/// Supports both global and service-specific configuration with composite primary key
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "service_config")]
struct ServiceConfigRecord {
    #[column(not_null, primary_key)]
    service_name: String,

    #[column(not_null, primary_key)]
    key: String,

    #[column(not_null)]
    value: String,

    #[column(default = "string")]
    r#type: String,

    description: Option<String>,

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Sync metadata table record
/// Tracks configuration synchronization status
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "sync_metadata")]
struct SyncMetadataRecord {
    #[column(primary_key)]
    service: String,

    #[column(not_null)]
    last_sync: String, // TIMESTAMP type

    version: Option<String>,
}

/// Service configuration table SQL (generated by Schema macro)
pub const SERVICE_CONFIG_TABLE: &str = ServiceConfigRecord::CREATE_TABLE_SQL;

/// Sync metadata table SQL (generated by Schema macro)
pub const SYNC_METADATA_TABLE: &str = SyncMetadataRecord::CREATE_TABLE_SQL;

/// Default port for comsrv service
pub const DEFAULT_PORT: u16 = 6001;

/// Channel core fields (shared between Config and API responses)
/// These fields represent the essential channel identity and state
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ChannelCore {
    /// Channel ID
    pub id: u16,

    /// Channel name
    pub name: String,

    /// Channel description
    pub description: Option<String>,

    /// Protocol type (modbus, virtual, grpc, etc.)
    pub protocol: String,

    /// Whether the channel is enabled
    #[serde(default = "default_true")]
    pub enabled: bool,
}

/// Channel configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ChannelConfig {
    /// Core channel fields
    #[serde(flatten)]
    pub core: ChannelCore,

    /// Protocol-specific parameters
    #[serde(default)]
    pub parameters: HashMap<String, serde_json::Value>,

    /// Channel logging configuration
    #[serde(default)]
    pub logging: ChannelLoggingConfig,
}

impl ChannelConfig {
    /// Convenient accessor for channel ID
    pub fn id(&self) -> u16 {
        self.core.id
    }

    /// Convenient accessor for channel name
    pub fn name(&self) -> &str {
        &self.core.name
    }

    /// Convenient accessor for protocol
    pub fn protocol(&self) -> &str {
        &self.core.protocol
    }

    /// Convenient accessor for enabled status
    pub fn is_enabled(&self) -> bool {
        self.core.enabled
    }
}

/// Channels table record
/// Stores channel configurations - Maps to ChannelConfig structure
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "channels")]
struct ChannelRecord {
    #[column(primary_key)]
    channel_id: u16,

    #[column(not_null, unique)]
    name: String,

    protocol: Option<String>,

    #[column(default = "true")]
    enabled: bool,

    config: Option<String>, // JSON TEXT

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Channels table SQL (generated by Schema macro)
pub const CHANNELS_TABLE: &str = ChannelRecord::CREATE_TABLE_SQL;

/// Channel-specific logging configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ChannelLoggingConfig {
    /// Whether logging is enabled for this channel
    #[serde(default)]
    pub enabled: bool,

    /// Log level for this channel
    pub level: Option<String>,

    /// Log file for this channel
    pub file: Option<String>,
}

/// Base point configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct Point {
    /// Point ID
    pub point_id: u32,

    /// Signal name
    pub signal_name: String,

    /// Point description
    pub description: Option<String>,

    /// Unit of measurement
    pub unit: Option<String>,
}

/// Telemetry point (T)
/// For analog measurements like voltage, current, temperature
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct TelemetryPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Scale factor for value conversion
    #[serde(default = "default_scale", deserialize_with = "deserialize_scale")]
    pub scale: f64,

    /// Offset for value conversion
    #[serde(default, deserialize_with = "deserialize_offset")]
    pub offset: f64,

    /// Data type (float32, float64, int16, int32, etc.)
    #[serde(default = "default_data_type")]
    pub data_type: String,

    /// Whether to reverse signal logic (not used for telemetry values)
    /// Note: Byte order/endian for multi-byte values is controlled via protocol mappings
    /// using the `byte_order` field, not this flag.
    /// Supports: 1/0, true/false, yes/no in CSV files
    #[serde(default, deserialize_with = "deserialize_bool_flexible")]
    pub reverse: bool,
}

/// Signal point (S)
/// For digital/binary status like on/off, open/close
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct SignalPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Whether to reverse the signal logic
    /// Supports: 1/0, true/false, yes/no in CSV files
    #[serde(default, deserialize_with = "deserialize_bool_flexible")]
    pub reverse: bool,
}

/// Control point (C)
/// For remote control commands
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ControlPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Control type (momentary, latching, etc.)
    #[serde(default = "default_control_type")]
    pub control_type: String,

    /// Control value for ON/OPEN command
    #[serde(default = "default_on_value")]
    pub on_value: u16,

    /// Control value for OFF/CLOSE command
    #[serde(default)]
    pub off_value: u16,

    /// Pulse duration in milliseconds (for momentary controls)
    pub pulse_duration_ms: Option<u32>,
}

/// Adjustment point (A)
/// For remote setpoint adjustments
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct AdjustmentPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Minimum allowed value
    pub min_value: Option<f64>,

    /// Maximum allowed value
    pub max_value: Option<f64>,

    /// Step size for adjustments
    #[serde(default = "default_step")]
    pub step: f64,

    /// Data type (float32, float64, int16, int32, etc.)
    #[serde(default = "default_data_type")]
    pub data_type: String,

    /// Scale factor for value conversion
    #[serde(default = "default_scale", deserialize_with = "deserialize_scale")]
    pub scale: f64,

    /// Offset for value conversion
    #[serde(default, deserialize_with = "deserialize_offset")]
    pub offset: f64,
}

/// Telemetry points table record
/// Stores analog measurement points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "telemetry_points",
    suffix = "PRIMARY KEY (channel_id, point_id)"
)]
struct TelemetryPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u16,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Signal points table record
/// Stores digital/binary status points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "signal_points", suffix = "PRIMARY KEY (channel_id, point_id)")]
struct SignalPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u16,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    #[column(default = "0")]
    normal_state: i32,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Control points table record
/// Stores remote control command points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "control_points", suffix = "PRIMARY KEY (channel_id, point_id)")]
struct ControlPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u16,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Adjustment points table record
/// Stores remote setpoint adjustment points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "adjustment_points",
    suffix = "PRIMARY KEY (channel_id, point_id)"
)]
struct AdjustmentPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u16,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Telemetry points table SQL (generated by Schema macro)
pub const TELEMETRY_POINTS_TABLE: &str = TelemetryPointRecord::CREATE_TABLE_SQL;

/// Signal points table SQL (generated by Schema macro)
pub const SIGNAL_POINTS_TABLE: &str = SignalPointRecord::CREATE_TABLE_SQL;

/// Control points table SQL (generated by Schema macro)
pub const CONTROL_POINTS_TABLE: &str = ControlPointRecord::CREATE_TABLE_SQL;

/// Adjustment points table SQL (generated by Schema macro)
pub const ADJUSTMENT_POINTS_TABLE: &str = AdjustmentPointRecord::CREATE_TABLE_SQL;
// ────────────────────── Channel Routing Table ──────────────────────

/// Channel routing table record (C2C routing)
/// Stores direct channel-to-channel data forwarding rules
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "channel_routing",
    suffix = "PRIMARY KEY (source_channel_id, source_type, source_point_id)"
)]
struct ChannelRoutingRecord {
    #[column(not_null, references = "channels(channel_id)")]
    source_channel_id: u16,

    #[column(not_null)]
    source_type: String, // T/S/C/A

    #[column(not_null)]
    source_point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    target_channel_id: u16,

    #[column(not_null)]
    target_type: String, // T/S/C/A

    #[column(not_null)]
    target_point_id: u32,

    #[column(default = "true")]
    enabled: bool,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    description: Option<String>,

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

// Schema SQL constant
pub const CHANNEL_ROUTING_TABLE: &str = ChannelRoutingRecord::CREATE_TABLE_SQL;

// DEPRECATED: Mapping tables removed - mappings are now stored as JSON in protocol_mappings column of point tables
// The mapping structures (ModbusMapping, VirtualMapping, etc.) are still used for JSON serialization/deserialization

// ============================================================================
// Protocol Mapping Structures
// ============================================================================

/// Modbus protocol mapping (corresponds to modbus_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct ModbusMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u16,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub slave_id: u8,
    pub function_code: u8,
    pub register_address: u16,
    pub data_type: String,
    pub byte_order: String,
    #[serde(default, deserialize_with = "deserialize_u8_default_zero")]
    pub bit_position: u8,
}

/// Virtual protocol mapping (corresponds to virtual_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct VirtualMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u16,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub expression: Option<String>,
    #[serde(default = "default_update_interval")]
    pub update_interval: Option<u32>,
    #[serde(default)]
    pub initial_value: Option<f64>,
    #[serde(default)]
    pub noise_range: Option<f64>,
}

fn default_update_interval() -> Option<u32> {
    Some(1000)
}

/// IEC 60870-5-104 protocol mapping (corresponds to iec_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct IecMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u16,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub asdu_address: i32,
    pub object_address: i32,
    pub type_id: i32,
    #[serde(default = "default_cot")]
    pub cot: i32,
    #[serde(default)]
    pub qualifier: i32,
}

fn default_cot() -> i32 {
    20 // Default Cause of Transmission
}

/// gRPC protocol mapping (corresponds to grpc_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct GrpcMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u16,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub service_name: String,
    pub method_name: String,
    pub field_path: Option<String>,
}

/// CAN protocol mapping (corresponds to can_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "schema", derive(JsonSchema))]
pub struct CanMapping {
    #[serde(default)] // channel_id comes from directory context
    pub channel_id: u16,
    pub point_id: u32,
    #[serde(default)] // telemetry_type comes from filename context
    pub telemetry_type: String,
    pub can_id: u32,
    #[serde(default)]
    pub msg_name: Option<String>,
    #[serde(default)]
    pub signal_name: Option<String>,
    pub start_bit: u32,  // Changed to u32 to match database
    pub bit_length: u32, // Changed to u32 to match database
    #[serde(default = "default_byte_order")]
    pub byte_order: String,
    #[serde(default = "default_data_type")]
    pub data_type: String,
    #[serde(default)]
    pub signed: bool,
    #[serde(default = "default_scale")]
    pub scale: f64,
    #[serde(default)]
    pub offset: f64,
    #[serde(default)]
    pub min_value: Option<f64>,
    #[serde(default)]
    pub max_value: Option<f64>,
    #[serde(default)]
    pub unit: Option<String>,
}

// Default value functions for serde
fn default_byte_order() -> String {
    "ABCD".to_string()
}

fn default_data_type() -> String {
    "uint32".to_string()
}

fn default_scale() -> f64 {
    1.0
}

/// Custom deserializer for f64 that treats empty strings as default value
/// Used for scale and offset fields in CSV files
fn deserialize_f64_or_default<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::Deserialize;

    #[derive(Deserialize)]
    #[serde(untagged)]
    enum StringOrFloat {
        String(String),
        Float(f64),
    }

    match StringOrFloat::deserialize(deserializer)? {
        StringOrFloat::Float(f) => Ok(f),
        StringOrFloat::String(s) => {
            if s.trim().is_empty() {
                Ok(0.0) // Empty string => 0.0 (offset default)
            } else {
                s.trim().parse::<f64>().map_err(serde::de::Error::custom)
            }
        },
    }
}

/// Deserialize scale with default 1.0 for empty strings
fn deserialize_scale<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    deserialize_f64_or_default(deserializer).map(|v| if v == 0.0 { 1.0 } else { v })
}

/// Deserialize offset with default 0.0 for empty strings
fn deserialize_offset<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    deserialize_f64_or_default(deserializer)
}

// ============================================================================
// Database Insertion Support - Automated binding through trait
// ============================================================================

use sqlx::{sqlite::SqliteQueryResult, Executor, Sqlite};

/// Trait for inserting point definitions into database
///
/// @trait SqlInsertablePoint
/// @purpose Auto-insert point definitions (telemetry/signal/control/adjustment)
/// @implementors TelemetryPoint, SignalPoint, ControlPoint, AdjustmentPoint
#[allow(async_fn_in_trait)]
pub trait SqlInsertablePoint {
    /// Execute insertion with automatic parameter binding for points
    ///
    /// @input executor: E - Database executor (connection or transaction)
    /// @input channel_id: u16 - Channel ID this point belongs to
    /// @output Result<SqliteQueryResult, sqlx::Error> - Rows affected and last insert ID
    /// @throws sqlx::Error - Foreign key constraints, duplicate keys
    /// @side-effects Inserts into points table with telemetry_type from implementor
    /// @example
    /// ```ignore
    /// let signal = SignalPoint { base: Point { id: 1, /* other fields */ }, reverse: true };
    /// signal.insert_with(&pool, 3001).await?;
    /// ```
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u16,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>;
}

// DEPRECATED: SqlInsertable implementations removed - mappings are now stored as JSON in point tables
// Mapping structures are still used for JSON serialization/deserialization

// ============================================================================
// Runtime Configuration Structure
// ============================================================================

/// Complete runtime channel configuration
/// Contains base configuration, points, and protocol mappings
#[derive(Debug, Clone)]
pub struct RuntimeChannelConfig {
    /// Base channel configuration (Arc-wrapped for zero-copy sharing)
    pub base: Arc<ChannelConfig>,

    /// Telemetry points
    pub telemetry_points: Vec<TelemetryPoint>,

    /// Signal points
    pub signal_points: Vec<SignalPoint>,

    /// Control points
    pub control_points: Vec<ControlPoint>,

    /// Adjustment points
    pub adjustment_points: Vec<AdjustmentPoint>,

    /// Modbus protocol mappings (if Modbus protocol)
    pub modbus_mappings: Vec<ModbusMapping>,

    /// Virtual protocol mappings (if Virtual protocol)
    pub virtual_mappings: Vec<VirtualMapping>,

    /// CAN protocol mappings (if CAN protocol)
    pub can_mappings: Vec<CanMapping>,
}

impl RuntimeChannelConfig {
    /// Create from base configuration (wraps in Arc for zero-copy sharing)
    pub fn from_base(base: ChannelConfig) -> Self {
        Self {
            base: Arc::new(base),
            telemetry_points: Vec::new(),
            signal_points: Vec::new(),
            control_points: Vec::new(),
            adjustment_points: Vec::new(),
            modbus_mappings: Vec::new(),
            virtual_mappings: Vec::new(),
            can_mappings: Vec::new(),
        }
    }

    /// Get channel ID
    pub fn id(&self) -> u16 {
        self.base.core.id
    }

    /// Get channel name
    pub fn name(&self) -> &str {
        &self.base.core.name
    }

    /// Get protocol
    pub fn protocol(&self) -> &str {
        &self.base.core.protocol
    }

    /// Check if enabled
    pub fn is_enabled(&self) -> bool {
        self.base.core.enabled
    }
}

// Default value functions
fn default_true() -> bool {
    true
}

fn default_control_type() -> String {
    "momentary".to_string()
}

fn default_on_value() -> u16 {
    1
}

fn default_step() -> f64 {
    1.0
}

// Default implementations
impl Default for ComsrvConfig {
    fn default() -> Self {
        let service = BaseServiceConfig {
            name: "comsrv".to_string(),
            ..Default::default()
        };

        let api = ApiConfig {
            host: "0.0.0.0".to_string(),
            port: 6001, // comsrv default port
        };

        Self {
            service,
            api,
            redis: RedisConfig::default(),
            logging: LoggingConfig::default(),
            channels: Vec::new(),
        }
    }
}

// ============================================================================
// Validation implementations
// ============================================================================

use crate::common::{ConfigValidator, ValidationLevel, ValidationResult};
use anyhow::{Context, Result};

impl ConfigValidator for ComsrvConfig {
    fn validate_syntax(&self) -> Result<ValidationResult> {
        // Syntax validation is mainly done during deserialization
        // If we get here, the YAML/JSON was parseable
        Ok(ValidationResult::new(ValidationLevel::Syntax))
    }

    fn validate_schema(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Schema);

        // Validate common components
        self.service.validate(&mut result);
        self.api.validate(&mut result);
        self.redis.validate(&mut result);
        self.logging.validate(&mut result);

        // Validate that at least one channel is configured
        if self.channels.is_empty() {
            result.add_error("Configuration must include at least one channel".to_string());
        }

        // Validate channels
        for (idx, channel) in self.channels.iter().enumerate() {
            channel.validate(&mut result, idx);
        }

        Ok(result)
    }

    fn validate_business(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Business);

        // Check for duplicate channel IDs
        let mut channel_ids = std::collections::HashSet::new();
        for channel in &self.channels {
            if !channel_ids.insert(channel.core.id) {
                result.add_error(format!("Duplicate channel ID: {}", channel.core.id));
            }
        }

        // Check for duplicate channel names
        let mut channel_names = std::collections::HashSet::new();
        for channel in &self.channels {
            if !channel_names.insert(&channel.core.name) {
                result.add_error(format!("Duplicate channel name: {}", channel.core.name));
            }
        }

        // Warn if no channels configured
        if self.channels.is_empty() {
            result.add_warning("No channels configured".to_string());
        }

        // Check if protocol is supported
        let supported_protocols = ["modbus_tcp", "modbus_rtu", "virtual", "grpc"];
        for channel in &self.channels {
            if !supported_protocols.contains(&channel.core.protocol.as_str()) {
                result.add_warning(format!(
                    "Channel {} uses unknown protocol: {}",
                    channel.core.name, channel.core.protocol
                ));
            }
        }

        Ok(result)
    }

    fn validate_runtime(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Runtime);

        // Port availability check
        self.api.validate_runtime(&mut result);

        // Redis connectivity would be checked here if needed
        // (async function would need to be called separately)

        Ok(result)
    }
}

impl ChannelConfig {
    /// Validate channel configuration
    pub fn validate(&self, result: &mut ValidationResult, idx: usize) {
        if self.core.name.is_empty() {
            result.add_error(format!("Channel {} name cannot be empty", idx));
        }

        if self.core.protocol.is_empty() {
            result.add_error(format!(
                "Channel {} protocol cannot be empty",
                self.core.name
            ));
        }

        // Protocol-specific parameter validation
        match self.core.protocol.as_str() {
            "modbus_tcp" => {
                if !self.parameters.contains_key("host") {
                    result.add_error(format!(
                        "Channel {}: Modbus TCP requires 'host' parameter",
                        self.core.name
                    ));
                }
                if !self.parameters.contains_key("port") {
                    result.add_error(format!(
                        "Channel {}: Modbus TCP requires 'port' parameter",
                        self.core.name
                    ));
                }
            },
            "modbus_rtu" => {
                if !self.parameters.contains_key("device") {
                    result.add_error(format!(
                        "Channel {}: Modbus RTU requires 'device' parameter",
                        self.core.name
                    ));
                }
                if !self.parameters.contains_key("baud_rate") {
                    result.add_error(format!(
                        "Channel {}: Modbus RTU requires 'baud_rate' parameter",
                        self.core.name
                    ));
                }
            },
            _ => {
                // Other protocols may have different requirements
            },
        }
    }
}

// Removed YAML-level lua_sync and command_trigger to reduce configuration surface.

/// Helper to create validator from YAML (for backward compatibility)
pub struct ComsrvValidator {
    config: Option<ComsrvConfig>,
    raw_yaml: Option<serde_yaml::Value>,
}

impl ComsrvValidator {
    pub fn from_yaml(yaml: serde_yaml::Value) -> Self {
        let config = serde_yaml::from_value(yaml.clone()).ok();
        Self {
            config,
            raw_yaml: Some(yaml),
        }
    }

    pub fn from_config(config: ComsrvConfig) -> Self {
        Self {
            config: Some(config),
            raw_yaml: None,
        }
    }

    pub fn from_file(path: &std::path::Path) -> Result<Self> {
        let content = std::fs::read_to_string(path)
            .with_context(|| format!("Failed to read file: {}", path.display()))?;

        // Deserialize directly from string to capture line/column information
        let config = serde_yaml::from_str::<ComsrvConfig>(&content).map_err(|e| {
            if let Some(location) = e.location() {
                anyhow::anyhow!(
                    "Configuration error in {}:{}:{}\n  {}",
                    path.display(),
                    location.line(),
                    location.column(),
                    e
                )
            } else {
                anyhow::anyhow!("Configuration error in {}\n  {}", path.display(), e)
            }
        })?;

        // Also parse as YAML Value for raw_yaml field
        let yaml: serde_yaml::Value = serde_yaml::from_str(&content)?;

        Ok(Self {
            config: Some(config),
            raw_yaml: Some(yaml),
        })
    }
}

impl ConfigValidator for ComsrvValidator {
    fn validate_syntax(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Syntax);

        if self.config.is_none() {
            if let Some(yaml) = &self.raw_yaml {
                match serde_yaml::from_value::<ComsrvConfig>(yaml.clone()) {
                    Ok(_) => {
                        result.add_warning("Configuration parsed but not stored".to_string());
                    },
                    Err(e) => {
                        result.add_error(format!("Invalid YAML syntax: {}", e));
                    },
                }
            } else {
                result.add_error("No configuration data available".to_string());
            }
        }

        Ok(result)
    }

    fn validate_schema(&self) -> Result<ValidationResult> {
        match &self.config {
            Some(config) => config.validate_schema(),
            None => {
                let mut result = ValidationResult::new(ValidationLevel::Schema);
                result.add_error("Configuration parsing failed".to_string());
                Ok(result)
            },
        }
    }

    fn validate_business(&self) -> Result<ValidationResult> {
        match &self.config {
            Some(config) => config.validate_business(),
            None => {
                let mut result = ValidationResult::new(ValidationLevel::Business);
                result.add_error("Configuration not available".to_string());
                Ok(result)
            },
        }
    }

    fn validate_runtime(&self) -> Result<ValidationResult> {
        match &self.config {
            Some(config) => config.validate_runtime(),
            None => {
                let mut result = ValidationResult::new(ValidationLevel::Runtime);
                result.add_error("Configuration not available".to_string());
                Ok(result)
            },
        }
    }
}

// ============================================================================
// Centralized Configuration Constants for Comsrv
// ============================================================================

/// Redis key patterns for comsrv data storage and command queues
///
/// This struct provides centralized Redis key patterns used by the communication
/// service for storing channel data and managing command queues. All keys follow
/// a consistent naming convention: `comsrv:{channel_id}:{type}`
///
/// # Key Patterns
///
/// - **Channel Data**: `comsrv:{channel_id}:{type}` - Stores real-time data from devices
///   - Types: T (Telemetry), S (Signal), C (Control), A (Adjustment)
/// - **Command Queues**: `comsrv:{channel_id}:{C|A}:TODO` - Pending commands to devices
///
/// # Example
/// ```rust
/// use voltage_config::comsrv::RedisKeys;
///
/// // Format a telemetry data key for channel 1001
/// let key = RedisKeys::channel_data(1001, "T");
/// assert_eq!(key, "comsrv:1001:T");
///
/// // Format a control command queue key
/// let todo_key = RedisKeys::control_todo(1001);
/// assert_eq!(todo_key, "comsrv:1001:C:TODO");
/// ```
pub struct RedisKeys;

impl RedisKeys {
    /// Channel data storage key pattern: "comsrv:{channel_id}:{point_type}"
    /// point_type: T (telemetry), S (signal), C (control), A (adjustment)
    pub const CHANNEL_DATA: &'static str = "comsrv:{}:{}";

    /// Control command TODO queue: "comsrv:{channel_id}:C:TODO"
    pub const CONTROL_TODO: &'static str = "comsrv:{}:C:TODO";

    /// Adjustment command TODO queue: "comsrv:{channel_id}:A:TODO"
    pub const ADJUSTMENT_TODO: &'static str = "comsrv:{}:A:TODO";

    /// Helper method to format channel data key
    pub fn channel_data(channel_id: u16, point_type: &str) -> String {
        format!("comsrv:{}:{}", channel_id, point_type)
    }

    /// Helper method to format control TODO key
    pub fn control_todo(channel_id: u16) -> String {
        format!("comsrv:{}:C:TODO", channel_id)
    }

    /// Helper method to format adjustment TODO key
    pub fn adjustment_todo(channel_id: u16) -> String {
        format!("comsrv:{}:A:TODO", channel_id)
    }

    /// Helper method to format channel point data key: "comsrv:{channel_id}:{type}:{point_id}"
    /// Used for storing individual point values within a channel
    pub fn channel_point_data(channel_id: u16, point_type: &str, point_id: u32) -> String {
        format!("comsrv:{}:{}:{}", channel_id, point_type, point_id)
    }

    /// Helper method to format channel timestamp key: "comsrv:{channel_id}:{type}:ts"
    /// Used for storing timestamp of last update for a channel data type
    pub fn channel_timestamp(channel_id: u16, point_type: &str) -> String {
        format!("comsrv:{}:{}:ts", channel_id, point_type)
    }

    /// Helper method to format channel raw data key: "comsrv:{channel_id}:{type}:raw"
    /// Used for storing raw/unprocessed data before transformation
    pub fn channel_raw_data(channel_id: u16, point_type: &str) -> String {
        format!("comsrv:{}:{}:raw", channel_id, point_type)
    }
}

/// Database table names for comsrv
///
/// Centralized table names used across the communication service.
/// These constants ensure consistency when accessing SQLite tables
/// and prevent typos in table names.
///
/// # Tables
///
/// - **points**: Main point definition table (signal names, scaling, units)
/// - **{protocol}_mappings**: Protocol-specific mapping tables
/// - **channels**: Channel configuration table
/// - **service_config**: Service-level configuration
///
/// # Example
/// ```rust
/// use voltage_config::comsrv::TableNames;
///
/// // Query from points table
/// let query = format!("SELECT * FROM {} WHERE channel_id = ?", TableNames::POINTS);
/// ```
pub struct TableNames;

impl TableNames {
    pub const POINTS: &'static str = "points";
    pub const MODBUS_MAPPINGS: &'static str = "modbus_mappings";
    pub const CAN_MAPPINGS: &'static str = "can_mappings";
    pub const VIRTUAL_MAPPINGS: &'static str = "virtual_mappings";
    pub const IEC_MAPPINGS: &'static str = "iec_mappings";
    pub const GRPC_MAPPINGS: &'static str = "grpc_mappings";
    pub const CHANNELS: &'static str = "channels";
    pub const SERVICE_CONFIG: &'static str = "service_config";
    pub const SYNC_METADATA: &'static str = "sync_metadata";
}

/// Configuration file keys for comsrv
///
/// Standard keys used in YAML/JSON configuration files and database storage.
/// These constants ensure consistency across configuration loading and validation code.
///
/// # Usage
/// ```ignore
/// use voltage_config::comsrv::ConfigKeys;
/// use std::collections::HashMap;
///
/// // Access protocol-specific configuration
/// let config: HashMap<String, serde_json::Value> = load_config();
/// if let Some(mappings) = config.get(ConfigKeys::CAN_MAPPINGS) {
///     // Process CAN mappings
/// }
/// ```
pub struct ConfigKeys;

impl ConfigKeys {
    pub const CAN_MAPPINGS: &'static str = "can_mappings";
    pub const MODBUS_MAPPINGS: &'static str = "modbus_mappings";
    pub const VIRTUAL_MAPPINGS: &'static str = "virtual_mappings";
    pub const IEC_MAPPINGS: &'static str = "iec_mappings";
    pub const GRPC_MAPPINGS: &'static str = "grpc_mappings";
}

// ============================================================================
// Centralized SQL Queries for Protocol Plugins
// ============================================================================

/// Protocol-specific SQL queries
///
/// Centralized SQL queries for all protocol plugins. Each query retrieves
/// point definitions joined with protocol-specific mappings. All queries
/// follow the same structure to ensure consistency across protocols.
///
/// # Query Structure
/// All queries follow this pattern:
/// 1. SELECT point fields (id, name, scale, offset, unit, etc.)
/// 2. LEFT JOIN with protocol-specific mapping table
/// 3. WHERE clause filtering by channel_id
///
/// # Design Philosophy
/// The points table is the authoritative source following the Four Remotes
/// standard. Protocol-specific details are in separate mapping tables.
///
/// # Example
/// ```no_run
/// use voltage_config::comsrv::ProtocolQueries;
/// use sqlx::SqlitePool;
/// use anyhow::Result;
///
/// async fn load_modbus_points(pool: &SqlitePool, channel_id: u16) -> Result<()> {
///     let points = sqlx::query(ProtocolQueries::MODBUS_TCP_POINTS)
///         .bind(channel_id)
///         .fetch_all(pool)
///         .await?;
///     Ok(())
/// }
/// ```
pub struct ProtocolQueries;

impl ProtocolQueries {
    /// CAN protocol point query with mappings
    pub const CAN_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.can_id, m.msg_name,
            m.start_bit, m.bit_length, m.byte_order,
            m.signed, m.min_value, m.max_value
        FROM points p
        LEFT JOIN can_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
    "#;

    /// Modbus TCP protocol point query with mappings
    pub const MODBUS_TCP_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.slave_id, m.function_code, m.register_address,
            m.data_type as modbus_data_type, m.byte_order, m.bit_position
        FROM points p
        LEFT JOIN modbus_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
        ORDER BY m.slave_id, m.function_code, m.register_address
    "#;

    /// Modbus RTU points query
    ///
    /// Uses the same query structure as Modbus TCP since both protocols
    /// share the same application layer. The only difference is the
    /// transport layer (TCP vs serial RTU).
    pub const MODBUS_RTU_POINTS: &'static str = Self::MODBUS_TCP_POINTS;

    /// Virtual protocol point query with mappings
    pub const VIRTUAL_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.simulation_type, m.min_value, m.max_value,
            m.frequency, m.amplitude, m.noise_level,
            m.initial_value, m.step
        FROM points p
        LEFT JOIN virtual_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
    "#;
}

// ============================================================================
// SqlInsertablePoint implementations for Point types
// ============================================================================

/// @implementor TelemetryPoint for SqlInsertablePoint
/// @telemetry-type "T" - Telemetry/measurement data
impl SqlInsertablePoint for TelemetryPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u16,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'T', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(self.scale)
        .bind(self.offset)
        .bind(&self.base.unit)
        .bind(self.reverse)
        .bind(&self.data_type)
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

/// @implementor SignalPoint for SqlInsertablePoint
/// @telemetry-type "S" - Signal/status data
/// @special Handles signal reversal via reverse field
impl SqlInsertablePoint for SignalPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u16,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'S', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(1.0)  // Scale default for signal
        .bind(0.0)  // Offset default for signal
        .bind(&self.base.unit)
        .bind(self.reverse)  // Use actual reverse value from SignalPoint
        .bind("uint16")  // Data type default for signal
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

/// @implementor ControlPoint for SqlInsertablePoint
/// @telemetry-type "C" - Control commands
impl SqlInsertablePoint for ControlPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u16,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'C', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(1.0)  // Scale default for control
        .bind(0.0)  // Offset default for control
        .bind(&self.base.unit)
        .bind(false)  // Reverse default for control
        .bind("uint16")  // Data type default for control
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

/// @implementor AdjustmentPoint for SqlInsertablePoint
/// @telemetry-type "A" - Adjustment/setpoint values
impl SqlInsertablePoint for AdjustmentPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u16,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'A', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(self.scale)
        .bind(self.offset)
        .bind(&self.base.unit)
        .bind(false)  // Reverse default for adjustment
        .bind(&self.data_type)
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

// ============================================================================
// CSV Header Validation - CsvFields Trait Implementations
// ============================================================================

use crate::validation::CsvFields;

impl CsvFields for TelemetryPoint {
    fn field_names() -> Vec<String> {
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for SignalPoint {
    fn field_names() -> Vec<String> {
        // Signal points use the same CSV format as telemetry
        // The 'reverse' field serves as signal logic inversion
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for ControlPoint {
    fn field_names() -> Vec<String> {
        // Control points use the same basic CSV format
        // Additional fields (control_type, on_value, etc.) have defaults
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for AdjustmentPoint {
    fn field_names() -> Vec<String> {
        // Adjustment points use the same basic CSV format
        // Additional fields (min_value, max_value, step) have defaults
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

#[cfg(test)]
#[allow(clippy::disallowed_methods)] // Test code - unwrap is acceptable
mod tests {
    use super::*;

    #[test]
    fn test_minimal_config_with_only_channels() {
        let yaml = r#"
channels:
  - id: 1001
    name: "Test Channel"
    protocol: "modbus_tcp"
    enabled: true
    parameters:
      host: "192.168.1.100"
      port: 502
    logging:
      enabled: false
"#;

        let config: ComsrvConfig =
            serde_yaml::from_str(yaml).expect("Should load minimal config with only channels");

        // Verify default values are used
        assert_eq!(config.service.name, "unnamed_service");
        assert_eq!(config.api.host, "0.0.0.0");
        assert_eq!(config.api.port, 6001);
        // Redis URL can be localhost or 127.0.0.1 depending on environment
        assert!(
            config.redis.url == "redis://127.0.0.1:6379"
                || config.redis.url == "redis://localhost:6379",
            "Unexpected redis.url: {}",
            config.redis.url
        );
        assert_eq!(config.channels.len(), 1);
        assert_eq!(config.channels[0].core.name, "Test Channel");
    }

    #[test]
    fn test_empty_config_uses_all_defaults() {
        let yaml = "{}";

        let config: ComsrvConfig =
            serde_yaml::from_str(yaml).expect("Should load empty config with all defaults");

        // Verify all default values
        assert_eq!(config.service.name, "unnamed_service");
        assert_eq!(config.api.host, "0.0.0.0");
        assert_eq!(config.api.port, 6001);
        // Redis URL can be localhost or 127.0.0.1 depending on environment
        assert!(
            config.redis.url == "redis://127.0.0.1:6379"
                || config.redis.url == "redis://localhost:6379",
            "Unexpected redis.url: {}",
            config.redis.url
        );
        assert_eq!(config.channels.len(), 0);
    }
}
