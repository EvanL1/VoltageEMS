//! Modsrv service configuration structures
//!
//! This module contains all modsrv-specific configuration types.

use anyhow::Result;
use common::{ApiConfig, BaseServiceConfig, RedisConfig, ValidationLevel, ValidationResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use voltage_schema_macro::Schema;

#[cfg(feature = "swagger-ui")]
use utoipa::ToSchema;

// ============================================================================
// Default Functions
// ============================================================================

/// Default API configuration for modsrv (port 6002)
fn default_modsrv_api() -> ApiConfig {
    ApiConfig {
        host: "0.0.0.0".to_string(),
        port: 6002,
    }
}

fn bool_true() -> bool {
    true
}

// ============================================================================
// Core Configuration
// ============================================================================

/// Default port for modsrv service
pub const DEFAULT_PORT: u16 = 6002;

/// Modsrv service configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModsrvConfig {
    /// Base service configuration
    #[serde(flatten)]
    pub service: BaseServiceConfig,

    /// API configuration (has default value)
    #[serde(default = "default_modsrv_api")]
    pub api: ApiConfig,

    /// Redis configuration (simplified - only url is used)
    #[serde(default)]
    pub redis: RedisConfig,

    /// Path to products directory
    #[serde(default)]
    pub products_path: Option<String>,

    /// Path to instances configuration
    #[serde(default)]
    pub instances_path: Option<String>,

    /// Whether to auto-load instances at startup
    #[serde(default = "bool_true")]
    pub auto_load_instances: bool,
}

impl Default for ModsrvConfig {
    fn default() -> Self {
        let service = BaseServiceConfig {
            name: "modsrv".to_string(),
            ..Default::default()
        };

        let api = ApiConfig {
            host: "0.0.0.0".to_string(),
            port: 6002, // modsrv default port
        };

        Self {
            service,
            api,
            redis: RedisConfig::default(),
            products_path: Some("config/modsrv/products".to_string()),
            instances_path: Some("config/modsrv/instances.yaml".to_string()),
            auto_load_instances: true,
        }
    }
}

// ============================================================================
// Database Schema Definitions
// ============================================================================

/// Re-export service config table SQL from common
pub use common::SERVICE_CONFIG_TABLE;

/// Re-export sync metadata table SQL from common
pub use common::SYNC_METADATA_TABLE;

/// Products table record - stores product hierarchy
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "products")]
struct ProductRecord {
    #[column(primary_key)]
    product_name: String,

    parent_name: Option<String>,

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type
}

/// Instances table record - stores instance configurations
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "instances")]
struct InstanceRecord {
    #[column(primary_key)]
    instance_id: u32,

    #[column(unique, not_null)]
    instance_name: String,

    #[column(not_null, references = "products(product_name)")]
    product_name: String,

    properties: Option<String>, // JSON TEXT

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Products table SQL (generated by Schema macro)
pub const PRODUCTS_TABLE: &str = ProductRecord::CREATE_TABLE_SQL;

/// Instances table SQL (generated by Schema macro)
pub const INSTANCES_TABLE: &str = InstanceRecord::CREATE_TABLE_SQL;

/// Measurement routing table record
/// Routes telemetry/signal points to measurement points (T/S → M)
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "measurement_routing",
    suffix = "UNIQUE(instance_id, measurement_id), CHECK(channel_type IN ('T','S'))"
)]
struct MeasurementRoutingRecord {
    #[column(primary_key, autoincrement)]
    routing_id: i64,

    #[column(not_null, references = "instances(instance_id)", on_delete = "CASCADE")]
    instance_id: u32,

    #[column(not_null)]
    instance_name: String,

    #[column(references = "channels(channel_id)", on_delete = "SET NULL")]
    channel_id: Option<u32>,

    channel_type: Option<String>,

    channel_point_id: Option<u32>,

    #[column(not_null)]
    measurement_id: u32,

    description: Option<String>,

    #[column(default = "true")]
    enabled: bool,

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Action routing table record
/// Routes action points to control/adjustment points (A → C/A)
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "action_routing",
    suffix = "UNIQUE(instance_id, action_id), CHECK(channel_type IN ('C','A'))"
)]
struct ActionRoutingRecord {
    #[column(primary_key, autoincrement)]
    routing_id: i64,

    #[column(not_null, references = "instances(instance_id)", on_delete = "CASCADE")]
    instance_id: u32,

    #[column(not_null)]
    instance_name: String,

    #[column(not_null)]
    action_id: u32,

    #[column(references = "channels(channel_id)", on_delete = "SET NULL")]
    channel_id: Option<u32>,

    channel_type: Option<String>,

    channel_point_id: Option<u32>,

    description: Option<String>,

    #[column(default = "true")]
    enabled: bool,

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Measurement routing table SQL (generated by Schema macro)
pub const MEASUREMENT_ROUTING_TABLE: &str = MeasurementRoutingRecord::CREATE_TABLE_SQL;

/// Action routing table SQL (generated by Schema macro)
pub const ACTION_ROUTING_TABLE: &str = ActionRoutingRecord::CREATE_TABLE_SQL;

// ============================================================================
// Product & Point Types
// ============================================================================

/// Complete product definition with nested structure
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "swagger-ui", derive(ToSchema))]
pub struct Product {
    /// Product name (unique identifier)
    pub product_name: String,

    /// Parent product name for hierarchy
    pub parent_name: Option<String>,

    /// Measurement points (includes physical and virtual)
    #[serde(default)]
    pub measurements: Vec<MeasurementPoint>,

    /// Action points
    #[serde(default)]
    pub actions: Vec<ActionPoint>,

    /// Property templates
    #[serde(default)]
    pub properties: Vec<PropertyTemplate>,
}

/// Measurement point definition (M type)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "swagger-ui", derive(ToSchema))]
pub struct MeasurementPoint {
    /// Measurement point ID (unique within product)
    #[serde(alias = "id", alias = "index")]
    pub measurement_id: u32,

    /// Point name
    pub name: String,

    /// Unit of measurement
    pub unit: Option<String>,

    /// Point description
    pub description: Option<String>,
}

/// Measurement points table record
/// Stores measurement point definitions for products
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "measurement_points",
    suffix = "PRIMARY KEY (product_name, measurement_id)"
)]
struct MeasurementPointRecord {
    #[column(not_null, references = "products(product_name)", on_delete = "CASCADE")]
    product_name: String,

    #[column(not_null)]
    measurement_id: u32,

    #[column(not_null)]
    name: String,

    unit: Option<String>,

    description: Option<String>,
}

/// Measurement points table SQL (generated by Schema macro)
pub const MEASUREMENT_POINTS_TABLE: &str = MeasurementPointRecord::CREATE_TABLE_SQL;

/// Action point definition (A type)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "swagger-ui", derive(ToSchema))]
pub struct ActionPoint {
    /// Action point ID (unique within product)
    #[serde(alias = "id", alias = "index")]
    pub action_id: u32,

    /// Action name
    pub name: String,

    /// Unit for adjustment actions
    pub unit: Option<String>,

    /// Point description
    pub description: Option<String>,
}

/// Action points table record
/// Stores action point definitions for products
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "action_points",
    suffix = "PRIMARY KEY (product_name, action_id)"
)]
struct ActionPointRecord {
    #[column(not_null, references = "products(product_name)", on_delete = "CASCADE")]
    product_name: String,

    #[column(not_null)]
    action_id: u32,

    #[column(not_null)]
    name: String,

    unit: Option<String>,

    description: Option<String>,
}

/// Action points table SQL (generated by Schema macro)
pub const ACTION_POINTS_TABLE: &str = ActionPointRecord::CREATE_TABLE_SQL;

/// Property template for instance configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "swagger-ui", derive(ToSchema))]
pub struct PropertyTemplate {
    /// Property ID (unique within product)
    #[serde(alias = "id", alias = "index")]
    pub property_id: i32,

    /// Property name
    pub name: String,

    /// Unit of the property
    pub unit: Option<String>,

    /// Property description
    pub description: Option<String>,
}

/// Property templates table record
/// Stores property template definitions for products
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "property_templates",
    suffix = "PRIMARY KEY (product_name, property_id)"
)]
struct PropertyTemplateRecord {
    #[column(not_null, references = "products(product_name)", on_delete = "CASCADE")]
    product_name: String,

    #[column(not_null)]
    property_id: i32,

    #[column(not_null)]
    name: String,

    unit: Option<String>,

    description: Option<String>,
}

/// Property templates table SQL (generated by Schema macro)
pub const PROPERTY_TEMPLATES_TABLE: &str = PropertyTemplateRecord::CREATE_TABLE_SQL;

// ============================================================================
// Instance Types
// ============================================================================

/// Instance core fields (shared between Config and API responses)
/// These fields represent the essential instance identity and properties
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstanceCore {
    /// Unique instance identifier (numeric)
    pub instance_id: u32,

    /// Instance name for Redis keys and API paths
    pub instance_name: String,

    /// Associated product name
    pub product_name: String,

    /// Instance properties (key-value pairs supporting multiple types)
    #[serde(default)]
    pub properties: HashMap<String, serde_json::Value>,
}

/// Instance definition for runtime devices
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Instance {
    /// Core instance fields
    #[serde(flatten)]
    pub core: InstanceCore,

    /// Point ID to Redis key mappings for measurements
    #[serde(skip_serializing_if = "Option::is_none")]
    pub measurement_mappings: Option<HashMap<u32, String>>,

    /// Action ID to Redis key mappings
    #[serde(skip_serializing_if = "Option::is_none")]
    pub action_mappings: Option<HashMap<u32, String>>,

    /// Creation timestamp
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

impl Instance {
    /// Convenient accessor for instance ID
    pub fn instance_id(&self) -> u32 {
        self.core.instance_id
    }

    /// Convenient accessor for instance name
    pub fn instance_name(&self) -> &str {
        &self.core.instance_name
    }

    /// Convenient accessor for product name
    pub fn product_name(&self) -> &str {
        &self.core.product_name
    }
}

/// Request to create a new instance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateInstanceRequest {
    /// Required unique identifier (numeric)
    pub instance_id: u32,

    /// Instance name for Redis keys
    pub instance_name: String,

    /// Product name
    pub product_name: String,

    /// Instance properties (supports multiple types: numbers, strings, etc.)
    #[serde(default)]
    pub properties: HashMap<String, serde_json::Value>,
}

/// Product hierarchy using tuples (following CLAUDE.md)
pub type ProductHierarchy = Vec<(String, Option<String>)>;

// Note: For point role (M/A), use voltage_model::PointRole
// For point type (T/S/C/A), use voltage_model::PointType

// ============================================================================
// Validation implementations
// ============================================================================

impl common::ConfigValidator for ModsrvConfig {
    fn validate_syntax(&self) -> Result<ValidationResult> {
        Ok(ValidationResult::new(ValidationLevel::Syntax))
    }

    fn validate_schema(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Schema);

        // Validate common components
        self.service.validate(&mut result);
        self.api.validate(&mut result);
        self.redis.validate(&mut result);

        // Service-specific validation
        if let Some(products_path) = &self.products_path {
            if products_path.is_empty() {
                result.add_error("Products path cannot be empty if specified".to_string());
            }
        }

        if let Some(instances_path) = &self.instances_path {
            if instances_path.is_empty() {
                result.add_error("Instances path cannot be empty if specified".to_string());
            }
        }

        Ok(result)
    }

    fn validate_business(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Business);

        // Business rule: Warn about auto-loading instances
        if !self.auto_load_instances {
            result.add_warning(
                "Instance auto-loading is disabled, instances must be created manually".to_string(),
            );
        }

        // Validate paths exist if specified
        if let Some(products_path) = &self.products_path {
            let path = std::path::Path::new(products_path);
            if !path.exists() {
                result.add_warning(format!("Products path does not exist: {}", products_path));
            }
        }

        if let Some(instances_path) = &self.instances_path {
            let path = std::path::Path::new(instances_path);
            if !path.exists() {
                result.add_warning(format!("Instances path does not exist: {}", instances_path));
            }
        }

        Ok(result)
    }

    fn validate_runtime(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Runtime);

        // Port availability check
        self.api.validate_runtime(&mut result);

        Ok(result)
    }
}

/// Type alias for backward compatibility - use GenericValidator directly for new code
pub type ModsrvValidator = common::GenericValidator<ModsrvConfig>;

// ============================================================================
// Centralized Configuration Constants for Modsrv
// ============================================================================

/// Redis key patterns for modsrv instance data
///
/// This struct centralizes Redis key patterns used by the model service.
/// All keys use instance_id (u16) instead of instance_name for rename-safety.
///
/// Two concepts are distinguished to avoid confusion:
/// - Address strings (used in routing tables): per-point address like
///   `inst:{instance_id}:M:{point_id}` / `inst:{instance_id}:A:{point_id}`.
///   These appear as field values in `route:c2m` / `route:m2c`, and are used for lookups.
/// - Runtime value storage: hash keys `inst:{instance_id}:M` and
///   `inst:{instance_id}:A`, with fields = point_id, storing the latest values.
///
/// # Key Patterns (ID-based, no service prefix)
///
/// - Address (measurement): `inst:{instance_id}:M:{point_id}`
/// - Address (action):      `inst:{instance_id}:A:{point_id}`
/// - Runtime (measurement): `inst:{instance_id}:M` (hash)
/// - Runtime (action):      `inst:{instance_id}:A` (hash)
/// - Instance name:         `inst:{instance_id}:name` (string)
/// - Status:                `inst:{instance_id}:status` (hash)
/// - Config:                `inst:{instance_id}:config` (hash)
pub struct InstanceRedisKeys;

impl InstanceRedisKeys {
    /// Address: `inst:{instance_id}:M:{point_id}`
    ///
    /// Used in routing tables as destination address strings.
    /// - First placeholder: instance_id (u16 numeric ID)
    /// - Second placeholder: point_id (numeric ID)
    pub const INSTANCE_MEASUREMENT: &'static str = "inst:{}:M:{}";

    /// Address: `inst:{instance_id}:A:{point_id}`
    ///
    /// Used in routing tables as destination address strings.
    /// - First placeholder: instance_id (u16 numeric ID)
    /// - Second placeholder: action point_id
    pub const INSTANCE_ACTION: &'static str = "inst:{}:A:{}";

    /// Instance status pattern: `inst:{instance_id}:status`
    ///
    /// Stores runtime status information for the instance including
    /// online/offline state, last update time, error conditions, etc.
    pub const INSTANCE_STATUS: &'static str = "inst:{}:status";

    /// Instance configuration pattern: `inst:{instance_id}:config`
    ///
    /// Stores instance-specific configuration including properties,
    /// calculation parameters, and runtime settings.
    pub const INSTANCE_CONFIG: &'static str = "inst:{}:config";

    /// Helper: address string for measurement
    pub fn measurement(instance_id: u32, point_id: u32) -> String {
        format!("inst:{}:M:{}", instance_id, point_id)
    }

    /// Helper: address string for action
    pub fn action(instance_id: u32, point_id: u32) -> String {
        format!("inst:{}:A:{}", instance_id, point_id)
    }

    /// Helper method to format status key
    pub fn status(instance_id: u32) -> String {
        format!("inst:{}:status", instance_id)
    }

    /// Helper method to format config key
    pub fn config(instance_id: u32) -> String {
        format!("inst:{}:config", instance_id)
    }

    /// Helper: runtime measurement hash key `inst:{instance_id}:M`
    pub fn measurement_hash(instance_id: u32) -> String {
        format!("inst:{}:M", instance_id)
    }

    /// Helper: runtime action hash key `inst:{instance_id}:A`
    pub fn action_hash(instance_id: u32) -> String {
        format!("inst:{}:A", instance_id)
    }

    /// Helper: instance name key `inst:{instance_id}:name`
    ///
    /// Stores the instance name as a separate string key.
    /// This enables efficient SCAN-based aggregation queries while maintaining ID-based keys.
    pub fn instance_name(instance_id: u32) -> String {
        format!("inst:{}:name", instance_id)
    }

    /// Helper: instance info key `instance:{instance_id}:info`
    pub fn instance_info(instance_id: u32) -> String {
        format!("instance:{}:info", instance_id)
    }

    /// Helper: instance attributes key `instance:{instance_id}:attributes`
    pub fn instance_attributes(instance_id: u32) -> String {
        format!("instance:{}:attributes", instance_id)
    }

    /// Helper: instance parameters key `instance:{instance_id}:parameters`
    pub fn instance_parameters(instance_id: u32) -> String {
        format!("instance:{}:parameters", instance_id)
    }

    // ============================================================================
    // Product-related keys (unchanged, use product_name)
    // ============================================================================

    /// Helper: product info key `modsrv:product:{product_name}`
    pub fn product(product_name: &str) -> String {
        format!("modsrv:product:{}", product_name)
    }

    /// Helper: product children set key `modsrv:product:{product_name}:children`
    pub fn product_children(product_name: &str) -> String {
        format!("modsrv:product:{}:children", product_name)
    }

    /// Helper: product measurements definition key `modsrv:product:{product_name}:measurements`
    pub fn product_measurements(product_name: &str) -> String {
        format!("modsrv:product:{}:measurements", product_name)
    }

    /// Helper: product actions definition key `modsrv:product:{product_name}:actions`
    pub fn product_actions(product_name: &str) -> String {
        format!("modsrv:product:{}:actions", product_name)
    }

    /// Helper: product properties definition key `modsrv:product:{product_name}:properties`
    pub fn product_properties(product_name: &str) -> String {
        format!("modsrv:product:{}:properties", product_name)
    }

    // ============================================================================
    // Instance point definition keys (ID-based)
    // ============================================================================

    /// Helper: instance measurement points definition key `inst:{instance_id}:measurement_points`
    pub fn instance_measurement_points(instance_id: u32) -> String {
        format!("inst:{}:measurement_points", instance_id)
    }

    /// Helper: instance action points definition key `inst:{instance_id}:action_points`
    pub fn instance_action_points(instance_id: u32) -> String {
        format!("inst:{}:action_points", instance_id)
    }

    // ============================================================================
    // Global instance index
    // ============================================================================

    /// Instance index set: `instance:index`
    /// Contains all active instance IDs
    pub const INSTANCE_INDEX: &'static str = "instance:index";

    /// Product index set: `modsrv:products`
    /// Contains all registered product names
    pub const PRODUCT_INDEX: &'static str = "modsrv:products";

    // ==================== Statistics Keys (Cross-Service) ====================

    /// Warning statistics hash: `modsrv:stats:warnings`
    /// Tracks various warning counts (queue overflow, high water mark, etc.)
    /// Used by: modsrv, common/warning_monitor, VoltageRedis Lua functions
    pub const STATS_WARNINGS: &'static str = "modsrv:stats:warnings";

    /// Last overflow timestamp hash: `modsrv:stats:last_overflow`
    /// Records the most recent overflow timestamp for each channel
    /// Used by: modsrv, VoltageRedis Lua functions
    pub const STATS_LAST_OVERFLOW: &'static str = "modsrv:stats:last_overflow";

    /// Routing statistics hash: `modsrv:stats:routed`
    /// Tracks the number of routed points by channel_id (diagnostic purposes)
    /// Used by: modsrv, VoltageRedis Lua functions
    pub const STATS_ROUTED: &'static str = "modsrv:stats:routed";
}

/// Centralized SQL queries for modsrv
///
/// Provides all SQL queries used by the model service for managing
/// products, instances, and point mappings.
pub struct ModsrvQueries;

impl ModsrvQueries {
    /// Check if an instance exists by ID
    pub const CHECK_INSTANCE_EXISTS: &'static str =
        "SELECT EXISTS(SELECT 1 FROM instances WHERE instance_id = ?)";

    /// Check if an instance exists by name
    pub const CHECK_INSTANCE_NAME_EXISTS: &'static str =
        "SELECT EXISTS(SELECT 1 FROM instances WHERE instance_name = ?)";

    /// Count all products
    pub const COUNT_PRODUCTS: &'static str = "SELECT COUNT(*) FROM products";

    /// Count all instances
    pub const COUNT_INSTANCES: &'static str = "SELECT COUNT(*) FROM instances";

    /// Load all instances
    pub const LOAD_ALL_INSTANCES: &'static str = r#"
        SELECT
            instance_id,
            instance_name,
            product_name,
            properties
        FROM instances
    "#;

    /// Load instance by ID
    pub const LOAD_INSTANCE_BY_ID: &'static str = r#"
        SELECT
            instance_id,
            instance_name,
            product_name,
            properties
        FROM instances
        WHERE instance_id = ?
    "#;

    /// Load product by name
    pub const LOAD_PRODUCT_BY_ID: &'static str = r#"
        SELECT
            product_name,
            parent_name,
            created_at
        FROM products
        WHERE product_name = ?
    "#;
}

/// Database table names for modsrv
pub struct TableNames;

impl TableNames {
    pub const PRODUCTS: &'static str = "products";
    pub const INSTANCES: &'static str = "instances";
    pub const MEASUREMENT_POINTS: &'static str = "measurement_points";
    pub const ACTION_POINTS: &'static str = "action_points";
    pub const PROPERTY_TEMPLATES: &'static str = "property_templates";
    pub const MEASUREMENT_ROUTING: &'static str = "measurement_routing";
    pub const ACTION_ROUTING: &'static str = "action_routing";
    pub const SERVICE_CONFIG: &'static str = "service_config";
    pub const SYNC_METADATA: &'static str = "sync_metadata";
}

// ============================================================================
// SqlInsertable trait implementation for modsrv types
// ============================================================================

use sqlx::{sqlite::SqliteQueryResult, Executor, Sqlite};

/// Trait for inserting modsrv product definitions into database
#[allow(async_fn_in_trait)]
pub trait SqlInsertableProduct {
    /// Execute insertion with automatic parameter binding
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        product_name: &str,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>;
}

impl SqlInsertableProduct for MeasurementPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        product_name: &str,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO measurement_points (product_name, measurement_id, name, unit, description)
            VALUES (?, ?, ?, ?, ?)
            "#,
        )
        .bind(product_name)
        .bind(self.measurement_id)
        .bind(&self.name)
        .bind(&self.unit)
        .bind(&self.description)
        .execute(executor)
        .await
    }
}

impl SqlInsertableProduct for ActionPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        product_name: &str,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO action_points (product_name, action_id, name, unit, description)
            VALUES (?, ?, ?, ?, ?)
            "#,
        )
        .bind(product_name)
        .bind(self.action_id)
        .bind(&self.name)
        .bind(&self.unit)
        .bind(&self.description)
        .execute(executor)
        .await
    }
}

impl SqlInsertableProduct for PropertyTemplate {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        product_name: &str,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO property_templates (product_name, property_id, name, unit, description)
            VALUES (?, ?, ?, ?, ?)
            "#,
        )
        .bind(product_name)
        .bind(self.property_id)
        .bind(&self.name)
        .bind(&self.unit)
        .bind(&self.description)
        .execute(executor)
        .await
    }
}

// ============================================================================
// Rules Configuration Types (for YAML config export/import)
// ============================================================================

/// Default API configuration for rules (port 6002, merged into modsrv)
fn default_rules_api() -> ApiConfig {
    ApiConfig {
        host: "0.0.0.0".to_string(),
        port: 6002,
    }
}

/// Rules service configuration
/// Used by monarch for YAML config export/import
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulesConfig {
    /// Base service configuration
    #[serde(flatten)]
    pub service: BaseServiceConfig,

    /// API configuration (has default value)
    #[serde(default = "default_rules_api")]
    pub api: ApiConfig,

    /// Redis configuration (simplified)
    #[serde(default)]
    pub redis: RedisConfig,

    /// Execution configuration
    #[serde(default)]
    pub execution: ExecutionConfig,
}

impl Default for RulesConfig {
    fn default() -> Self {
        let service = BaseServiceConfig {
            name: "rules".to_string(),
            ..Default::default()
        };

        let api = ApiConfig {
            host: "0.0.0.0".to_string(),
            port: 6002, // merged into modsrv
        };

        Self {
            service,
            api,
            redis: RedisConfig::default(),
            execution: ExecutionConfig::default(),
        }
    }
}

/// Rule execution configuration (reserved for future use)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExecutionConfig {}

/// Rule core fields (shared between Config and API responses)
/// These fields represent the essential rule identity and state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleCore {
    /// Rule ID
    pub id: i64,

    /// Rule name
    pub name: String,

    /// Rule description
    pub description: Option<String>,

    /// Whether the rule is enabled
    #[serde(default = "bool_true")]
    pub enabled: bool,

    /// Priority (higher number = higher priority)
    #[serde(default)]
    pub priority: u32,
}

/// Individual rule configuration for vue-flow/node-red
/// Used by monarch for YAML config export/import
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleConfig {
    /// Core rule fields
    #[serde(flatten)]
    pub core: RuleCore,

    /// Complete flow graph JSON (nodes, edges, viewport, etc.)
    pub flow_json: serde_json::Value,
}

impl RuleConfig {
    /// Convenient accessor for rule ID
    pub fn id(&self) -> i64 {
        self.core.id
    }

    /// Convenient accessor for rule name
    pub fn name(&self) -> &str {
        &self.core.name
    }

    /// Convenient accessor for enabled status
    pub fn is_enabled(&self) -> bool {
        self.core.enabled
    }

    /// Convenient accessor for priority
    pub fn priority(&self) -> u32 {
        self.core.priority
    }
}

// ============================================================================
// RulesConfig Validation Implementation
// ============================================================================

impl common::ConfigValidator for RulesConfig {
    fn validate_syntax(&self) -> Result<ValidationResult> {
        Ok(ValidationResult::new(ValidationLevel::Syntax))
    }

    fn validate_schema(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Schema);

        // Validate common components
        self.service.validate(&mut result);
        self.api.validate(&mut result);
        self.redis.validate(&mut result);

        Ok(result)
    }

    fn validate_business(&self) -> Result<ValidationResult> {
        let result = ValidationResult::new(ValidationLevel::Business);
        Ok(result)
    }

    fn validate_runtime(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Runtime);

        // Port availability check
        self.api.validate_runtime(&mut result);

        Ok(result)
    }
}
