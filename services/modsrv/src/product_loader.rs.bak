//! Product Configuration Loader for ModSrv
//! Loads product templates from CSV files with nested structure

#![allow(dead_code)]

use anyhow::{Context, Result};
use csv::ReaderBuilder;
use serde::Deserialize;
use sqlx::SqlitePool;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use tokio::fs;
use tracing::{debug, info, warn};

// Import all types from voltage-config instead of defining locally
// Re-export them as public so other modules can access them
pub use voltage_config::modsrv::{
    ActionPoint, CreateInstanceRequest, Instance, MeasurementPoint, PointType, Product,
    ProductHierarchy, PropertyTemplate,
};

/// Product hierarchy from products.yaml (local helper type for YAML parsing)
#[derive(Debug, Deserialize)]
struct ProductsYaml {
    products: HashMap<String, Option<String>>,
}

#[derive(Clone)]
pub struct ProductLoader {
    products_dir: PathBuf,
    pool: SqlitePool,
}

impl ProductLoader {
    pub fn new(products_dir: impl Into<PathBuf>, pool: SqlitePool) -> Self {
        Self {
            products_dir: products_dir.into(),
            pool,
        }
    }

    /// Helper function to load CSV file
    async fn load_csv<T>(&self, path: &Path) -> Result<Vec<T>>
    where
        T: for<'de> Deserialize<'de>,
    {
        let content = fs::read_to_string(path).await?;
        let mut rdr = ReaderBuilder::new()
            .has_headers(true)
            .from_reader(content.as_bytes());

        let mut records = Vec::new();
        for result in rdr.deserialize() {
            let record: T = result?;
            records.push(record);
        }
        Ok(records)
    }

    /// Initialize database tables with separate tables for each point type
    pub async fn init_database(&self) -> Result<()> {
        info!("Initializing product tables");

        // Products table (just hierarchy)
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS products (
                product_name TEXT PRIMARY KEY,
                parent_name TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Measurement points table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS measurement_points (
                product_name TEXT NOT NULL,
                measurement_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                unit TEXT,
                description TEXT,
                PRIMARY KEY (product_name, measurement_id),
                FOREIGN KEY (product_name) REFERENCES products(product_name) ON DELETE CASCADE
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Action points table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS action_points (
                product_name TEXT NOT NULL,
                action_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                unit TEXT,
                description TEXT,
                PRIMARY KEY (product_name, action_id),
                FOREIGN KEY (product_name) REFERENCES products(product_name) ON DELETE CASCADE
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Property templates table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS property_templates (
                product_name TEXT NOT NULL,
                property_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                unit TEXT,
                description TEXT,
                PRIMARY KEY (product_name, property_id),
                FOREIGN KEY (product_name) REFERENCES products(product_name) ON DELETE CASCADE
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Create instances table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS instances (
                instance_id INTEGER PRIMARY KEY,
                instance_name TEXT UNIQUE NOT NULL,
                product_name TEXT NOT NULL,
                properties TEXT,  -- JSON format
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (product_name) REFERENCES products(product_name)
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Create instance mappings table for point-to-redis-key mappings
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS instance_mappings (
                instance_id INTEGER,
                point_type TEXT,  -- 'M' or 'A'
                point_id INTEGER,
                redis_key TEXT,
                PRIMARY KEY (instance_id, point_type, point_id),
                FOREIGN KEY (instance_id) REFERENCES instances(instance_id) ON DELETE CASCADE
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Create point mappings table for channel-instance point routing
        // UNIQUE constraint ensures each instance point has only one data source
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS point_mappings (
                mapping_id INTEGER PRIMARY KEY AUTOINCREMENT,
                instance_id INTEGER NOT NULL,
                channel_id INTEGER NOT NULL,
                channel_type TEXT NOT NULL CHECK(channel_type IN ('T','S','C','A')),
                channel_point_id INTEGER NOT NULL,
                instance_type TEXT NOT NULL CHECK(instance_type IN ('M','A')),
                instance_point_id INTEGER NOT NULL,
                description TEXT,
                enabled BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(instance_id, instance_type, instance_point_id),
                FOREIGN KEY (instance_id) REFERENCES instances(instance_id) ON DELETE CASCADE
            )
            "#,
        )
        .execute(&self.pool)
        .await?;

        // Create indexes
        sqlx::query(
            "CREATE INDEX IF NOT EXISTS idx_mapping_channel ON point_mappings(channel_id, channel_type)",
        )
        .execute(&self.pool)
        .await?;

        sqlx::query(
            "CREATE INDEX IF NOT EXISTS idx_mapping_instance ON point_mappings(instance_id)",
        )
        .execute(&self.pool)
        .await?;

        info!("Product tables initialized");
        Ok(())
    }

    /// Load all products from the products directory
    pub async fn load_all(&self) -> Result<()> {
        // Log absolute path for debugging
        let abs_path =
            std::fs::canonicalize(&self.products_dir).unwrap_or_else(|_| self.products_dir.clone());
        info!("Loading products from: {}", abs_path.display());

        // Check if force reload is enabled
        let force_reload = std::env::var("MODSRV_FORCE_RELOAD")
            .unwrap_or_else(|_| "false".to_string())
            .to_lowercase()
            == "true";

        if force_reload {
            warn!("FORCE RELOAD enabled - clearing existing product data");

            // Clear existing data in transaction
            let mut tx = self.pool.begin().await?;
            sqlx::query("DELETE FROM property_templates")
                .execute(&mut *tx)
                .await?;
            sqlx::query("DELETE FROM action_points")
                .execute(&mut *tx)
                .await?;
            sqlx::query("DELETE FROM measurement_points")
                .execute(&mut *tx)
                .await?;
            sqlx::query("DELETE FROM products")
                .execute(&mut *tx)
                .await?;
            tx.commit().await?;

            info!("Existing product data cleared");
        } else {
            info!("Incremental loading mode - existing data will be preserved");
        }

        // Check if products directory exists
        if !self.products_dir.exists() {
            warn!("Products directory does not exist: {:?}", self.products_dir);
            return Ok(());
        }

        // Load product hierarchy from products.yaml
        let products_yaml_file = self.products_dir.join("products.yaml");
        if !products_yaml_file.exists() {
            warn!("No products.yaml file found");
            return Ok(());
        }

        let hierarchy = self.load_hierarchy(&products_yaml_file).await?;

        // Load each product's CSV files
        for (product_name, parent_name) in &hierarchy {
            // Prevent path traversal
            if product_name.contains("..")
                || product_name.contains("/")
                || product_name.contains("\\")
            {
                warn!("Skipping invalid product_name: {}", product_name);
                continue;
            }

            let product_dir = self.products_dir.join(product_name);
            if product_dir.exists() && product_dir.is_dir() {
                self.load_product_from_csv(product_name, parent_name.as_deref(), &product_dir)
                    .await?;
            } else {
                debug!("Product directory not found: {:?}", product_dir);
            }
        }

        info!("Product loading completed");
        Ok(())
    }

    /// Load product hierarchy from products.yaml
    async fn load_hierarchy(&self, file_path: &Path) -> Result<ProductHierarchy> {
        info!("Loading product hierarchy from {:?}", file_path);

        let yaml_content = tokio::fs::read_to_string(file_path)
            .await
            .context("Failed to read products.yaml")?;

        let products_yaml: ProductsYaml =
            serde_yaml::from_str(&yaml_content).context("Failed to parse products.yaml")?;

        let hierarchy: ProductHierarchy = products_yaml.products.into_iter().collect();

        info!("Loaded {} product definitions", hierarchy.len());
        Ok(hierarchy)
    }

    /// Load a single product from CSV files
    async fn load_product_from_csv(
        &self,
        product_name: &str,
        parent_name: Option<&str>,
        product_dir: &Path,
    ) -> Result<()> {
        // Prevent path traversal (additional safeguard)
        if product_name.contains("..") || product_name.contains("/") || product_name.contains("\\")
        {
            return Err(anyhow::anyhow!(
                "Invalid product_name: contains path traversal characters"
            ));
        }

        debug!("Loading product {} from {:?}", product_name, product_dir);

        // Insert product into database
        sqlx::query(
            r#"
            INSERT INTO products (product_name, parent_name)
            VALUES (?, ?)
            ON CONFLICT(product_name) DO UPDATE SET
                parent_name = excluded.parent_name
            "#,
        )
        .bind(product_name)
        .bind(parent_name)
        .execute(&self.pool)
        .await?;

        // Load measurements.csv (physical measurement points)
        let measurements_file = product_dir.join("measurements.csv");
        if measurements_file.exists() {
            let measurements: Vec<MeasurementPoint> = self
                .load_csv(&measurements_file)
                .await
                .context(format!("Failed to load measurements for {}", product_name))?;

            let measurement_count = measurements.len();
            for m in measurements {
                sqlx::query(
                    r#"
                    INSERT INTO measurement_points
                    (product_name, measurement_id, name, unit, description)
                    VALUES (?, ?, ?, ?, ?)
                    ON CONFLICT(product_name, measurement_id) DO UPDATE SET
                        name = excluded.name,
                        unit = excluded.unit,
                        description = excluded.description
                    "#,
                )
                .bind(product_name)
                .bind(m.measurement_id)
                .bind(&m.name)
                .bind(&m.unit)
                .bind(&m.description)
                .execute(&self.pool)
                .await?;
            }
            debug!(
                "Loaded {} measurements for {}",
                measurement_count, product_name
            );
        }

        // Load actions.csv
        let actions_file = product_dir.join("actions.csv");
        if actions_file.exists() {
            let actions: Vec<ActionPoint> = self
                .load_csv(&actions_file)
                .await
                .context(format!("Failed to load actions for {}", product_name))?;

            let action_count = actions.len();
            for a in actions {
                sqlx::query(
                    r#"
                    INSERT INTO action_points
                    (product_name, action_id, name, unit, description)
                    VALUES (?, ?, ?, ?, ?)
                    ON CONFLICT(product_name, action_id) DO UPDATE SET
                        name = excluded.name,
                        unit = excluded.unit,
                        description = excluded.description
                    "#,
                )
                .bind(product_name)
                .bind(a.action_id)
                .bind(&a.name)
                .bind(&a.unit)
                .bind(&a.description)
                .execute(&self.pool)
                .await?;
            }
            debug!("Loaded {} actions for {}", action_count, product_name);
        }

        // Load properties.csv
        let properties_file = product_dir.join("properties.csv");
        if properties_file.exists() {
            let properties: Vec<PropertyTemplate> = self
                .load_csv(&properties_file)
                .await
                .context(format!("Failed to load properties for {}", product_name))?;

            let property_count = properties.len();
            for p in properties {
                sqlx::query(
                    r#"
                    INSERT INTO property_templates
                    (product_name, property_id, name, unit, description)
                    VALUES (?, ?, ?, ?, ?)
                    ON CONFLICT(product_name, property_id) DO UPDATE SET
                        name = excluded.name,
                        unit = excluded.unit,
                        description = excluded.description
                    "#,
                )
                .bind(product_name)
                .bind(p.property_id)
                .bind(&p.name)
                .bind(&p.unit)
                .bind(&p.description)
                .execute(&self.pool)
                .await?;
            }
            debug!("Loaded {} properties for {}", property_count, product_name);
        }

        Ok(())
    }

    /// Get a complete product with nested structure
    ///
    /// @input product_name: &str - Product identifier to retrieve
    /// @output Result<Product> - Product with all point definitions
    /// @throws anyhow::Error - Product not found or database error
    /// @loads measurement_points, action_points, property_templates tables
    /// @side-effects None (read-only)
    pub async fn get_product(&self, product_name: &str) -> Result<Product> {
        // Get product basic info
        let (product_name_db, parent_name_db) = sqlx::query_as::<_, (String, Option<String>)>(
            "SELECT product_name, parent_name FROM products WHERE product_name = ?",
        )
        .bind(product_name)
        .fetch_one(&self.pool)
        .await
        .context(format!("Product not found: {}", product_name))?;

        // Get measurement points
        let measurements = sqlx::query_as::<_, (i32, String, Option<String>, Option<String>)>(
            r#"
            SELECT point_index, name, unit, description
            FROM measurement_points
            WHERE product_name = ?
            ORDER BY point_index
            "#,
        )
        .bind(product_name)
        .fetch_all(&self.pool)
        .await?
        .into_iter()
        .map(|(point_index, name, unit, description)| MeasurementPoint {
            measurement_id: point_index as u32,
            name,
            unit,
            description,
        })
        .collect();

        // Get action points
        let actions = sqlx::query_as::<_, (i32, String, Option<String>, Option<String>)>(
            r#"
            SELECT point_index, name, unit, description
            FROM action_points
            WHERE product_name = ?
            ORDER BY point_index
            "#,
        )
        .bind(product_name)
        .fetch_all(&self.pool)
        .await?
        .into_iter()
        .map(|(point_index, name, unit, description)| ActionPoint {
            action_id: point_index as u32,
            name,
            unit,
            description,
        })
        .collect();

        // Get property templates
        let properties = sqlx::query_as::<_, (i32, String, Option<String>, Option<String>)>(
            r#"
            SELECT point_index, name, unit, description
            FROM property_templates
            WHERE product_name = ?
            ORDER BY point_index
            "#,
        )
        .bind(product_name)
        .fetch_all(&self.pool)
        .await?
        .into_iter()
        .map(|(point_index, name, unit, description)| PropertyTemplate {
            property_id: point_index,
            name,
            unit,
            description,
        })
        .collect();

        Ok(Product {
            product_name: product_name_db,
            parent_name: parent_name_db,
            measurements,
            actions,
            properties,
        })
    }

    /// Get all products
    ///
    /// @input None
    /// @output Result<Vec<Product>> - All products with complete definitions
    /// @throws anyhow::Error - Database query error
    /// @side-effects None (read-only)
    /// @performance O(n*m) where n=products, m=points per product
    pub async fn get_all_products(&self) -> Result<Vec<Product>> {
        let product_names = sqlx::query_scalar::<_, String>(
            "SELECT product_name FROM products ORDER BY product_name",
        )
        .fetch_all(&self.pool)
        .await?;

        let mut products = Vec::new();
        for name in product_names {
            products.push(self.get_product(&name).await?);
        }

        Ok(products)
    }

    /// Get product hierarchy
    ///
    /// @input None
    /// @output Result<ProductHierarchy> - Vec<(product_name, parent_name)> tuples
    /// @throws anyhow::Error - Database query error
    /// @side-effects None (read-only)
    /// @returns Flat list of parent-child relationships
    pub async fn get_product_hierarchy(&self) -> Result<ProductHierarchy> {
        let rows = sqlx::query_as::<_, (String, Option<String>)>(
            "SELECT product_name, parent_name FROM products ORDER BY product_name",
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(rows)
    }

    /// Get all product names without loading point details
    ///
    /// This is a lightweight query that returns only product basic information
    /// (product_name and parent_name) without loading measurements, actions, or properties.
    /// Ideal for frontend dropdown lists or selection interfaces.
    ///
    /// @input None
    /// @output Result<Vec<(String, Option<String>)>> - Vec of (product_name, parent_name) tuples
    /// @throws anyhow::Error - Database query error
    /// @side-effects None (read-only)
    /// @performance O(n) where n=product count - much faster than get_all_products()
    pub async fn get_all_product_names(&self) -> Result<Vec<(String, Option<String>)>> {
        let rows = sqlx::query_as::<_, (String, Option<String>)>(
            "SELECT product_name, parent_name FROM products ORDER BY product_name",
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(rows)
    }

    /// Add a measurement point to a product
    pub async fn add_measurement(
        &self,
        product_name: &str,
        point: &MeasurementPoint,
    ) -> Result<()> {
        sqlx::query(
            r#"
            INSERT INTO measurement_points
            (product_name, point_index, name, unit, description)
            VALUES (?, ?, ?, ?, ?)
            ON CONFLICT(product_name, point_index) DO UPDATE SET
                name = excluded.name,
                unit = excluded.unit,
                description = excluded.description
            "#,
        )
        .bind(product_name)
        .bind(point.measurement_id)
        .bind(&point.name)
        .bind(&point.unit)
        .bind(&point.description)
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    /// Generate Redis key for a point
    pub fn get_redis_key(instance: &str, point_type: PointType, id: i32) -> String {
        // Use the as_str() method from PointRole (aliased as PointType)
        let type_prefix = point_type.as_str();
        format!("modsrv:{}:{}:{}", instance, type_prefix, id)
    }
}

#[cfg(test)]
#[allow(clippy::disallowed_methods)] // Test code - unwrap is acceptable
mod tests {
    use super::*;
    use sqlx::Row;
    use std::fs;
    use tempfile::TempDir;

    async fn setup_test_env() -> Result<(ProductLoader, TempDir)> {
        let temp_dir = TempDir::new()?;
        let db_path = temp_dir.path().join("test.db");
        let sqlite_url = format!("sqlite:{}?mode=rwc", db_path.display());
        let pool = SqlitePool::connect(&sqlite_url).await?;

        // Use standard modsrv schema from common test utils
        common::test_utils::schema::init_modsrv_schema(&pool).await?;

        let products_dir = temp_dir.path().join("products");
        fs::create_dir_all(&products_dir)?;

        let loader = ProductLoader::new(&products_dir, pool);

        Ok((loader, temp_dir))
    }

    fn create_test_products_yaml(dir: &Path) -> Result<()> {
        let yaml_content = r#"products:
  pv_inverter:
  battery_system: pv_inverter
"#;
        fs::write(dir.join("products.yaml"), yaml_content)?;
        Ok(())
    }

    fn create_test_measurements_csv(dir: &Path) -> Result<()> {
        let csv_content = r#"point_index,name,unit,description
1,DC Voltage,V,DC input voltage
2,DC Current,A,DC input current
3,AC Power,kW,AC output power
"#;
        fs::write(dir.join("measurements.csv"), csv_content)?;
        Ok(())
    }

    fn create_test_actions_csv(dir: &Path) -> Result<()> {
        let csv_content = r#"action_id,name,unit,description
1,Power Switch,,On/Off control
2,Set Power,kW,Power setpoint
"#;
        fs::write(dir.join("actions.csv"), csv_content)?;
        Ok(())
    }

    fn create_test_properties_csv(dir: &Path) -> Result<()> {
        let csv_content = r#"property_id,name,unit,description
1,rated_power,kW,Rated Power
2,max_voltage,V,Max Voltage
"#;
        fs::write(dir.join("properties.csv"), csv_content)?;
        Ok(())
    }

    #[tokio::test]
    async fn test_init_database() {
        let (loader, _temp_dir) = setup_test_env().await.expect("Failed to setup test env");

        // Verify tables were created
        let result = sqlx::query("SELECT name FROM sqlite_master WHERE type='table'")
            .fetch_all(&loader.pool)
            .await
            .expect("Failed to query tables");

        let table_names: Vec<String> = result
            .iter()
            .map(|row| row.try_get::<String, _>("name").unwrap())
            .collect();

        assert!(table_names.contains(&"products".to_string()));
        assert!(table_names.contains(&"measurement_points".to_string()));
        assert!(table_names.contains(&"action_points".to_string()));
        assert!(table_names.contains(&"property_templates".to_string()));
    }

    #[tokio::test]
    async fn test_load_and_get_product() -> Result<()> {
        let (loader, temp_dir) = setup_test_env().await.expect("Failed to setup test env");
        let products_dir = temp_dir.path().join("products");

        create_test_products_yaml(&products_dir).expect("Failed to create test YAML");

        // Create product directory with CSV files
        let pv_dir = products_dir.join("pv_inverter");
        fs::create_dir_all(&pv_dir)?;
        create_test_measurements_csv(&pv_dir)?;
        create_test_actions_csv(&pv_dir)?;
        create_test_properties_csv(&pv_dir)?;

        // Load all products
        loader.load_all().await.expect("Failed to load products");

        // Get the product with nested structure
        let product = loader
            .get_product("pv_inverter")
            .await
            .expect("Failed to get product");

        // Verify product structure
        assert_eq!(product.product_name, "pv_inverter");
        assert_eq!(product.parent_name, None);

        // Check measurements
        assert_eq!(product.measurements.len(), 3);
        assert_eq!(product.measurements[0].measurement_id, 1);
        assert_eq!(product.measurements[0].name, "DC Voltage");
        assert_eq!(product.measurements[0].unit, Some("V".to_string()));
        assert_eq!(
            product.measurements[0].description,
            Some("DC input voltage".to_string())
        );

        // Check actions
        assert_eq!(product.actions.len(), 2);
        assert_eq!(product.actions[0].action_id, 1);
        assert_eq!(product.actions[0].name, "Power Switch");
        assert_eq!(
            product.actions[0].description,
            Some("On/Off control".to_string())
        );

        // Check properties
        assert_eq!(product.properties.len(), 2);
        assert_eq!(product.properties[0].property_id, 1);
        assert_eq!(product.properties[0].name, "rated_power");
        assert_eq!(
            product.properties[0].description,
            Some("Rated Power".to_string())
        );

        Ok(())
    }

    #[tokio::test]
    async fn test_add_measurement() -> Result<()> {
        let (loader, temp_dir) = setup_test_env().await.expect("Failed to setup test env");
        let products_dir = temp_dir.path().join("products");

        // Create and load basic product
        create_test_products_yaml(&products_dir)?;
        let pv_dir = products_dir.join("pv_inverter");
        fs::create_dir_all(&pv_dir)?;
        create_test_measurements_csv(&pv_dir)?;

        loader.load_all().await?;

        // Add additional measurement
        let new_point = MeasurementPoint {
            measurement_id: 101,
            name: "Total Power".to_string(),
            unit: Some("kW".to_string()),
            description: Some("Total calculated power".to_string()),
        };

        loader.add_measurement("pv_inverter", &new_point).await?;

        // Get product and verify point was added
        let product = loader.get_product("pv_inverter").await?;

        let added_point = product
            .measurements
            .iter()
            .find(|m| m.measurement_id == 101);
        assert!(added_point.is_some());

        let ap = added_point.unwrap();
        assert_eq!(ap.name, "Total Power");
        assert_eq!(ap.description, Some("Total calculated power".to_string()));

        Ok(())
    }

    #[test]
    fn test_redis_key_generation() {
        let key = ProductLoader::get_redis_key("pv_inv_001", PointType::Measurement, 1);
        assert_eq!(key, "modsrv:pv_inv_001:M:1");

        let key = ProductLoader::get_redis_key("pv_inv_001", PointType::Action, 1);
        assert_eq!(key, "modsrv:pv_inv_001:A:1");
    }
}
