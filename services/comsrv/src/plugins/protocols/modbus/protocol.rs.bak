//! Modbus protocol core implementation
//!
//! Integrates protocol processing, polling mechanism and batch optimization features
//! Note: Current version is a temporary implementation, focused on compilation

use async_trait::async_trait;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{Mutex, RwLock};
use tokio::task::JoinHandle;
use tracing::{debug, error, info, warn};

use crate::core::combase::traits::{ChannelCommand, TelemetryBatch};
use crate::core::combase::{ChannelStatus, ComBase, ComClient, PointDataMap, RedisValue};
use crate::core::config::types::{ChannelConfig, TelemetryType};
use crate::utils::error::{ComSrvError, Result};

use super::connection::{ConnectionParams, ModbusConnectionManager, ModbusMode as ConnectionMode};
use super::pdu::{ModbusPdu, PduBuilder};
use super::transport::{ModbusFrameProcessor, ModbusMode};
use super::types::{ModbusPoint, ModbusPollingConfig};

/// Modbus protocol implementation, implements `ComBase` trait
pub struct ModbusProtocol {
    /// Protocol name
    name: Arc<str>,
    /// Channel ID
    channel_id: u16,
    /// Channel configuration
    channel_config: Option<Arc<ChannelConfig>>, // Use Arc to avoid cloning

    /// Connection manager
    connection_manager: Arc<ModbusConnectionManager>,
    /// Frame processor for request/response correlation
    frame_processor: Arc<Mutex<ModbusFrameProcessor>>,

    /// State management
    is_connected: Arc<RwLock<bool>>,
    status: Arc<RwLock<ChannelStatus>>,

    /// Task management
    polling_handle: Arc<RwLock<Option<JoinHandle<()>>>>,
    command_handle: Arc<RwLock<Option<JoinHandle<()>>>>,

    /// Polling configuration
    polling_config: Arc<ModbusPollingConfig>, // Use Arc to avoid cloning
    /// Point mapping - separated by telemetry type for proper isolation
    telemetry_points: Arc<RwLock<Vec<ModbusPoint>>>,
    signal_points: Arc<RwLock<Vec<ModbusPoint>>>,
    control_points: Arc<RwLock<Vec<ModbusPoint>>>,
    adjustment_points: Arc<RwLock<Vec<ModbusPoint>>>,

    /// Data channel for sending telemetry data
    data_channel: Option<tokio::sync::mpsc::Sender<TelemetryBatch>>,

    /// Command receiver for receiving control commands
    command_rx: Arc<RwLock<Option<tokio::sync::mpsc::Receiver<ChannelCommand>>>>,
}

impl std::fmt::Debug for ModbusProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ModbusProtocol")
            .field("name", &self.name)
            .field("channel_id", &self.channel_id)
            .field("is_connected", &self.is_connected)
            .field("polling_config", &self.polling_config)
            .finish()
    }
}

impl ModbusProtocol {
    /// Create new Modbus protocol instance
    pub fn new(
        channel_config: ChannelConfig,
        connection_params: ConnectionParams,
        polling_config: ModbusPollingConfig,
    ) -> Result<Self> {
        let mode = if channel_config.protocol.contains("tcp") {
            ModbusMode::Tcp
        } else {
            ModbusMode::Rtu
        };

        let conn_mode = if channel_config.protocol.contains("tcp") {
            ConnectionMode::Tcp
        } else {
            ConnectionMode::Rtu
        };

        let polling_config = Arc::new(polling_config); // Wrap in Arc once
        let connection_manager =
            Arc::new(ModbusConnectionManager::new(conn_mode, connection_params));
        let frame_processor = Arc::new(Mutex::new(ModbusFrameProcessor::new(mode)));

        Ok(Self {
            name: channel_config.name.clone().into(),
            channel_id: channel_config.id,
            channel_config: Some(Arc::new(channel_config)), // Wrap in Arc
            connection_manager,
            frame_processor,
            is_connected: Arc::new(RwLock::new(false)),
            status: Arc::new(RwLock::new(ChannelStatus::default())),
            polling_handle: Arc::new(RwLock::new(None)),
            command_handle: Arc::new(RwLock::new(None)),
            polling_config,
            telemetry_points: Arc::new(RwLock::new(Vec::new())),
            signal_points: Arc::new(RwLock::new(Vec::new())),
            control_points: Arc::new(RwLock::new(Vec::new())),
            adjustment_points: Arc::new(RwLock::new(Vec::new())),
            data_channel: None,
            command_rx: Arc::new(RwLock::new(None)),
        })
    }
}

#[async_trait]
impl ComBase for ModbusProtocol {
    fn name(&self) -> &str {
        &self.name
    }

    fn protocol_type(&self) -> &'static str {
        "modbus"
    }

    fn get_channel_id(&self) -> u16 {
        self.channel_id
    }

    async fn get_status(&self) -> ChannelStatus {
        self.status.read().await.clone()
    }

    async fn initialize(&mut self, channel_config: Arc<ChannelConfig>) -> Result<()> {
        voltage_libs::log_to_channel!(
            channel_config.id,
            tracing::Level::INFO,
            "Initializing Modbus protocol - Step 1: Starting initialization"
        );

        self.channel_config = Some(channel_config.clone()); // Already Arc

        // Step 2: Load and parse point configurations
        voltage_libs::log_to_channel!(
            channel_config.id,
            tracing::Level::INFO,
            "Step 2: Loading point configurations"
        );

        // Create separate collections for each telemetry type
        let mut telemetry_modbus_points = Vec::new();
        let mut signal_modbus_points = Vec::new();
        let mut control_modbus_points = Vec::new();
        let mut adjustment_modbus_points = Vec::new();

        let total_configured_points = channel_config.telemetry_points.len()
            + channel_config.signal_points.len()
            + channel_config.control_points.len()
            + channel_config.adjustment_points.len();

        info!("Channel {} - Step 2: Processing {} configured points ({} telemetry, {} signal, {} control, {} adjustment)", 
            channel_config.id,
            total_configured_points,
            channel_config.telemetry_points.len(),
            channel_config.signal_points.len(),
            channel_config.control_points.len(),
            channel_config.adjustment_points.len()
        );

        // Process telemetry points
        for point in channel_config.telemetry_points.values() {
            // Read fields directly from protocol_params
            if let (Some(slave_id_str), Some(function_code_str), Some(register_address_str)) = (
                point.protocol_params.get("slave_id"),
                point.protocol_params.get("function_code"),
                point.protocol_params.get("register_address"),
            ) {
                if let (Ok(slave_id), Ok(function_code), Ok(register_address)) = (
                    slave_id_str.parse::<u8>(),
                    function_code_str.parse::<u8>(),
                    register_address_str.parse::<u16>(),
                ) {
                    // Get data type
                    let data_type = point
                        .protocol_params
                        .get("data_type")
                        .unwrap_or(&"uint16".to_string())
                        .to_string();

                    // Auto-determine register count based on data type
                    let register_count = point
                        .protocol_params
                        .get("register_count")
                        .and_then(|v| v.parse::<u16>().ok())
                        .unwrap_or(match data_type.as_str() {
                            "float32" | "float32_be" | "float32_le" => 2,
                            "uint32" | "int32" | "uint32_be" | "uint32_le" => 2,
                            "float64" | "float64_be" | "float64_le" => 4,
                            "uint64" | "int64" => 4,
                            _ => 1, // Default for uint16, int16, bool, etc.
                        });

                    info!(
                        "Loaded Modbus point: id={}, slave={}, func={}, addr={}, format={}, reg_count={}, bit_pos={:?}, type={}",
                        point.point_id,
                        slave_id,
                        function_code,
                        register_address,
                        &data_type,
                        register_count,
                        point.protocol_params.get("bit_position"),
                        &point.telemetry_type
                    );

                    let modbus_point = ModbusPoint {
                        point_id: point.point_id.to_string(),
                        slave_id,
                        function_code,
                        register_address,
                        data_type,
                        register_count,
                        byte_order: point.protocol_params.get("byte_order").cloned(),
                        bit_position: point
                            .protocol_params
                            .get("bit_position")
                            .and_then(|v| v.parse::<u8>().ok()),
                    };

                    telemetry_modbus_points.push(modbus_point);
                } else {
                    warn!(
                        "Failed to parse Modbus parameters for point {}: slave_id={}, function_code={}, register_address={}",
                        point.point_id, slave_id_str, function_code_str, register_address_str
                    );
                }
            } else {
                warn!(
                    "Missing Modbus parameters for point {}: {:?}",
                    point.point_id, point.protocol_params
                );
            }
        }

        // Process signal points
        for point in channel_config.signal_points.values() {
            if let (Some(slave_id_str), Some(function_code_str), Some(register_address_str)) = (
                point.protocol_params.get("slave_id"),
                point.protocol_params.get("function_code"),
                point.protocol_params.get("register_address"),
            ) {
                if let (Ok(slave_id), Ok(function_code), Ok(register_address)) = (
                    slave_id_str.parse::<u8>(),
                    function_code_str.parse::<u8>(),
                    register_address_str.parse::<u16>(),
                ) {
                    let data_type = point
                        .protocol_params
                        .get("data_type")
                        .unwrap_or(&"uint16".to_string())
                        .to_string();

                    let register_count = point
                        .protocol_params
                        .get("register_count")
                        .and_then(|v| v.parse::<u16>().ok())
                        .unwrap_or(1);

                    let modbus_point = ModbusPoint {
                        point_id: point.point_id.to_string(),
                        slave_id,
                        function_code,
                        register_address,
                        data_type,
                        register_count,
                        byte_order: point.protocol_params.get("byte_order").cloned(),
                        bit_position: point
                            .protocol_params
                            .get("bit_position")
                            .and_then(|v| v.parse::<u8>().ok()),
                    };
                    signal_modbus_points.push(modbus_point);
                }
            }
        }

        // Process control points (for write operations)
        for point in channel_config.control_points.values() {
            if let (Some(slave_id_str), Some(function_code_str), Some(register_address_str)) = (
                point.protocol_params.get("slave_id"),
                point.protocol_params.get("function_code"),
                point.protocol_params.get("register_address"),
            ) {
                if let (Ok(slave_id), Ok(function_code), Ok(register_address)) = (
                    slave_id_str.parse::<u8>(),
                    function_code_str.parse::<u8>(),
                    register_address_str.parse::<u16>(),
                ) {
                    let data_type = point
                        .protocol_params
                        .get("data_type")
                        .unwrap_or(&"uint16".to_string())
                        .to_string();

                    let register_count = 1;

                    let modbus_point = ModbusPoint {
                        point_id: point.point_id.to_string(),
                        slave_id,
                        function_code,
                        register_address,
                        data_type,
                        register_count,
                        byte_order: point.protocol_params.get("byte_order").cloned(),
                        bit_position: point
                            .protocol_params
                            .get("bit_position")
                            .and_then(|v| v.parse::<u8>().ok()),
                    };
                    control_modbus_points.push(modbus_point);
                }
            }
        }

        // Process adjustment points (for write operations)
        for point in channel_config.adjustment_points.values() {
            if let (Some(slave_id_str), Some(function_code_str), Some(register_address_str)) = (
                point.protocol_params.get("slave_id"),
                point.protocol_params.get("function_code"),
                point.protocol_params.get("register_address"),
            ) {
                if let (Ok(slave_id), Ok(function_code), Ok(register_address)) = (
                    slave_id_str.parse::<u8>(),
                    function_code_str.parse::<u8>(),
                    register_address_str.parse::<u16>(),
                ) {
                    let data_type = point
                        .protocol_params
                        .get("data_type")
                        .unwrap_or(&"float32".to_string())
                        .to_string();

                    let register_count = match data_type.as_str() {
                        "float32" | "float32_be" | "float32_le" => 2,
                        "uint32" | "int32" => 2,
                        _ => 1,
                    };

                    let modbus_point = ModbusPoint {
                        point_id: point.point_id.to_string(),
                        slave_id,
                        function_code,
                        register_address,
                        data_type,
                        register_count,
                        byte_order: point.protocol_params.get("byte_order").cloned(),
                        bit_position: None,
                    };
                    adjustment_modbus_points.push(modbus_point);
                }
            }
        }

        // Step 3: Set points to core and local storage
        let total_points = telemetry_modbus_points.len()
            + signal_modbus_points.len()
            + control_modbus_points.len()
            + adjustment_modbus_points.len();
        info!(
            "Channel {} - Step 3: Setting up {} points in storage (T:{}, S:{}, C:{}, A:{})",
            channel_config.id,
            total_points,
            telemetry_modbus_points.len(),
            signal_modbus_points.len(),
            control_modbus_points.len(),
            adjustment_modbus_points.len()
        );

        // Store points by type
        *self.telemetry_points.write().await = telemetry_modbus_points;
        *self.signal_points.write().await = signal_modbus_points;
        *self.control_points.write().await = control_modbus_points;
        *self.adjustment_points.write().await = adjustment_modbus_points;

        self.status.write().await.points_count = total_points;

        info!(
            "Channel {} - Step 3 completed: Successfully configured {} total points",
            channel_config.id, total_points
        );

        info!("Channel {} - Initialization completed successfully (connection will be established later)", channel_config.id);
        Ok(())
    }

    async fn read_four_telemetry(&self, _telemetry_type: TelemetryType) -> Result<PointDataMap> {
        // Data is collected via polling mechanism, not direct reads
        // Return empty map as polling handles data collection
        Ok(HashMap::new())
    }
}

#[async_trait]
impl ComClient for ModbusProtocol {
    fn is_connected(&self) -> bool {
        // Use try_read to avoid blocking in async context
        self.is_connected
            .try_read()
            .map(|guard| *guard)
            .unwrap_or(false)
    }

    async fn connect(&mut self) -> Result<()> {
        info!(
            "Channel {} - Connection Phase: Starting connection to Modbus device",
            self.channel_id
        );

        // Establish connection
        info!(
            "Channel {} - Establishing Modbus connection...",
            self.channel_id
        );
        self.connection_manager.connect().await?;
        info!(
            "Channel {} - Modbus connection established successfully",
            self.channel_id
        );

        *self.is_connected.write().await = true;
        self.status.write().await.is_connected = true;

        // Start periodic tasks (polling, etc.)
        info!("Channel {} - Starting periodic tasks...", self.channel_id);
        self.start_periodic_tasks().await?;
        info!(
            "Channel {} - Connection phase completed successfully",
            self.channel_id
        );

        Ok(())
    }

    async fn disconnect(&mut self) -> Result<()> {
        info!("Disconnecting Modbus for channel {}", self.channel_id);

        // stoppingalltask
        self.stop_periodic_tasks().await?;

        // disconnectedconnection
        self.connection_manager.disconnect().await?;

        *self.is_connected.write().await = false;
        self.status.write().await.is_connected = false;

        Ok(())
    }

    async fn control(&mut self, mut commands: Vec<(u32, RedisValue)>) -> Result<Vec<(u32, bool)>> {
        if !self.is_connected() {
            return Err(ComSrvError::NotConnected);
        }

        // Check if we have any pending commands from the command receiver
        if let Ok(mut rx_guard) = self.command_rx.try_write() {
            if let Some(rx) = rx_guard.as_mut() {
                // Process any pending control commands
                while let Ok(command) = rx.try_recv() {
                    match command {
                        ChannelCommand::Control {
                            command_id,
                            point_id,
                            value,
                            timestamp,
                        } => {
                            info!(
                                "Processing queued control command {} at timestamp {}",
                                command_id, timestamp
                            );
                            commands.push((point_id, RedisValue::Float(value)));
                        },
                        _ => {
                            // This is an adjustment command, skip it here
                        },
                    }
                }
            }
        }

        let mut results = Vec::new();
        let channel_config = self
            .channel_config
            .as_ref()
            .ok_or_else(|| ComSrvError::config("Channel configuration not initialized"))?;

        // Use the persistent frame processor
        let mut frame_processor = self.frame_processor.lock().await;

        for (point_id, value) in commands {
            info!(
                "Executing control command: point {}, value {:?}",
                point_id, value
            );

            // Find point configuration
            let point_config = match channel_config.control_points.get(&point_id) {
                Some(config) => config,
                None => {
                    error!("Control point {} not found in configuration", point_id);
                    results.push((point_id, false));
                    continue;
                },
            };

            // Get Modbus parameters
            let slave_id = point_config
                .protocol_params
                .get("slave_id")
                .and_then(|v| v.parse::<u8>().ok())
                .unwrap_or(1);

            let function_code = point_config
                .protocol_params
                .get("function_code")
                .and_then(|v| v.parse::<u8>().ok())
                .unwrap_or(5); // Default to FC05 for control

            let register_address = point_config
                .protocol_params
                .get("register_address")
                .and_then(|v| v.parse::<u16>().ok())
                .ok_or_else(|| {
                    ComSrvError::config(format!("Missing register_address for point {}", point_id))
                })?;

            let data_type = point_config
                .protocol_params
                .get("data_type")
                .map(|s| s.as_str())
                .unwrap_or("bool");

            let byte_order = point_config
                .protocol_params
                .get("byte_order")
                .map(|s| s.as_str());

            // Encode value
            let register_values = match encode_value_for_modbus(&value, data_type, byte_order) {
                Ok(values) => values,
                Err(e) => {
                    error!("Failed to encode value for point {}: {}", point_id, e);
                    results.push((point_id, false));
                    continue;
                },
            };

            // Build PDU based on function code
            let pdu = match function_code {
                5 => {
                    // FC05: Write Single Coil
                    let bool_value = register_values.first().map(|&v| v != 0).unwrap_or(false);
                    build_write_fc05_single_coil_pdu(register_address, bool_value)?
                },
                6 => {
                    // FC06: Write Single Register
                    let reg_value = register_values.first().copied().unwrap_or(0);
                    build_write_fc06_single_register_pdu(register_address, reg_value)?
                },
                15 => {
                    // FC15: Write Multiple Coils
                    let bool_values: Vec<bool> = register_values.iter().map(|&v| v != 0).collect();
                    build_write_fc15_multiple_coils_pdu(register_address, &bool_values)?
                },
                16 => {
                    // FC16: Write Multiple Registers
                    build_write_fc16_multiple_registers_pdu(register_address, &register_values)?
                },
                _ => {
                    error!("Unsupported function code {} for control", function_code);
                    results.push((point_id, false));
                    continue;
                },
            };

            // Build frame and send
            let request = frame_processor.build_frame(slave_id, &pdu);

            // Send request and receive response atomically
            let mut response = vec![0u8; 256];
            match self
                .connection_manager
                .send_and_receive(&request, &mut response, Duration::from_secs(5))
                .await
            {
                Ok(bytes_read) => {
                    response.truncate(bytes_read);

                    // Parse response
                    match frame_processor.parse_frame(&response) {
                        Ok((received_unit_id, response_pdu)) => {
                            if received_unit_id != slave_id {
                                error!(
                                    "Unit ID mismatch: expected {}, got {}",
                                    slave_id, received_unit_id
                                );
                                results.push((point_id, false));
                                continue;
                            }

                            // Parse write response
                            match parse_modbus_write_response(&response_pdu, function_code) {
                                Ok(_) => {
                                    info!("Control command successful for point {}", point_id);
                                    results.push((point_id, true));

                                    // Update status
                                    self.status.write().await.success_count += 1;
                                },
                                Err(e) => {
                                    error!("Control command failed for point {}: {}", point_id, e);
                                    results.push((point_id, false));
                                    self.status.write().await.error_count += 1;
                                },
                            }
                        },
                        Err(e) => {
                            error!("Failed to parse response for point {}: {}", point_id, e);
                            results.push((point_id, false));
                            self.status.write().await.error_count += 1;
                        },
                    }
                },
                Err(e) => {
                    error!("Failed to receive response for point {}: {}", point_id, e);
                    results.push((point_id, false));
                    self.status.write().await.error_count += 1;
                },
            }
        }

        self.status.write().await.last_update = chrono::Utc::now().timestamp();
        Ok(results)
    }

    async fn adjustment(
        &mut self,
        mut adjustments: Vec<(u32, RedisValue)>,
    ) -> Result<Vec<(u32, bool)>> {
        if !self.is_connected() {
            return Err(ComSrvError::NotConnected);
        }

        // Check if we have any pending commands from the command receiver
        if let Ok(mut rx_guard) = self.command_rx.try_write() {
            if let Some(rx) = rx_guard.as_mut() {
                // Process any pending adjustment commands
                while let Ok(command) = rx.try_recv() {
                    match command {
                        ChannelCommand::Adjustment {
                            command_id,
                            point_id,
                            value,
                            timestamp,
                        } => {
                            info!(
                                "Processing queued adjustment command {} at timestamp {}",
                                command_id, timestamp
                            );
                            adjustments.push((point_id, RedisValue::Float(value)));
                        },
                        _ => {
                            // This is a control command, skip it here
                        },
                    }
                }
            }
        }

        let mut results = Vec::new();
        let channel_config = self
            .channel_config
            .as_ref()
            .ok_or_else(|| ComSrvError::config("Channel configuration not initialized"))?;

        // Use the persistent frame processor
        let mut frame_processor = self.frame_processor.lock().await;

        for (point_id, value) in adjustments {
            info!(
                "Executing adjustment command: point {}, value {:?}",
                point_id, value
            );

            // Find point configuration
            let point_config = match channel_config.adjustment_points.get(&point_id) {
                Some(config) => config,
                None => {
                    error!("Adjustment point {} not found in configuration", point_id);
                    results.push((point_id, false));
                    continue;
                },
            };

            // Get Modbus parameters
            let slave_id = point_config
                .protocol_params
                .get("slave_id")
                .and_then(|v| v.parse::<u8>().ok())
                .unwrap_or(1);

            let function_code = point_config
                .protocol_params
                .get("function_code")
                .and_then(|v| v.parse::<u8>().ok())
                .unwrap_or(6); // Default to FC06 for adjustment

            let register_address = point_config
                .protocol_params
                .get("register_address")
                .and_then(|v| v.parse::<u16>().ok())
                .ok_or_else(|| {
                    ComSrvError::config(format!("Missing register_address for point {}", point_id))
                })?;

            let data_type = point_config
                .protocol_params
                .get("data_type")
                .map(|s| s.as_str())
                .unwrap_or("uint16");

            let byte_order = point_config
                .protocol_params
                .get("byte_order")
                .map(|s| s.as_str());

            // Apply scaling if configured (reverse scaling for write)
            let scaled_value = if let Some(scaling_info) = &point_config.scaling {
                match &value {
                    RedisValue::Float(f) => {
                        // Reverse scaling: (value - offset) / scale
                        let raw = (f - scaling_info.offset) / scaling_info.scale;
                        RedisValue::Float(raw)
                    },
                    RedisValue::Integer(i) => {
                        // Convert to float, reverse scale, then back to integer
                        let f = *i as f64;
                        let raw = ((f - scaling_info.offset) / scaling_info.scale) as i64;
                        RedisValue::Integer(raw)
                    },
                    _ => value.clone(),
                }
            } else {
                value.clone()
            };

            // Encode value
            let register_values =
                match encode_value_for_modbus(&scaled_value, data_type, byte_order) {
                    Ok(values) => values,
                    Err(e) => {
                        error!("Failed to encode value for point {}: {}", point_id, e);
                        results.push((point_id, false));
                        continue;
                    },
                };

            // Build PDU based on function code
            let pdu = match function_code {
                6 => {
                    // FC06: Write Single Register
                    let reg_value = register_values.first().copied().unwrap_or(0);
                    build_write_fc06_single_register_pdu(register_address, reg_value)?
                },
                16 => {
                    // FC16: Write Multiple Registers
                    build_write_fc16_multiple_registers_pdu(register_address, &register_values)?
                },
                _ => {
                    error!("Unsupported function code {} for adjustment", function_code);
                    results.push((point_id, false));
                    continue;
                },
            };

            // Build frame and send
            let request = frame_processor.build_frame(slave_id, &pdu);

            // Send request and receive response atomically
            let mut response = vec![0u8; 256];
            match self
                .connection_manager
                .send_and_receive(&request, &mut response, Duration::from_secs(5))
                .await
            {
                Ok(bytes_read) => {
                    response.truncate(bytes_read);

                    // Parse response
                    match frame_processor.parse_frame(&response) {
                        Ok((received_unit_id, response_pdu)) => {
                            if received_unit_id != slave_id {
                                error!(
                                    "Unit ID mismatch: expected {}, got {}",
                                    slave_id, received_unit_id
                                );
                                results.push((point_id, false));
                                continue;
                            }

                            // Parse write response
                            match parse_modbus_write_response(&response_pdu, function_code) {
                                Ok(_) => {
                                    info!("Adjustment command successful for point {}", point_id);
                                    results.push((point_id, true));

                                    // Update status
                                    self.status.write().await.success_count += 1;
                                },
                                Err(e) => {
                                    error!(
                                        "Adjustment command failed for point {}: {}",
                                        point_id, e
                                    );
                                    results.push((point_id, false));
                                    self.status.write().await.error_count += 1;
                                },
                            }
                        },
                        Err(e) => {
                            error!("Failed to parse response for point {}: {}", point_id, e);
                            results.push((point_id, false));
                            self.status.write().await.error_count += 1;
                        },
                    }
                },
                Err(e) => {
                    error!("Failed to receive response for point {}: {}", point_id, e);
                    results.push((point_id, false));
                    self.status.write().await.error_count += 1;
                },
            }
        }

        self.status.write().await.last_update = chrono::Utc::now().timestamp();
        Ok(results)
    }

    // In the four-telemetry detached architecture, update_points method has been removed,
    // point configuration is loaded directly during initialization stage

    async fn start_periodic_tasks(&self) -> Result<()> {
        info!(
            "Starting Modbus periodic tasks for channel {}",
            self.channel_id
        );

        // Start polling task
        if self.polling_config.enabled {
            let channel_id = self.channel_id;
            let polling_interval = self.polling_config.default_interval_ms;
            let connection_manager = self.connection_manager.clone();
            let telemetry_points = self.telemetry_points.clone();
            let signal_points = self.signal_points.clone();
            let status = self.status.clone();
            let is_connected = self.is_connected.clone();
            let channel_config = self.channel_config.clone();
            debug!(
                "Cloning channel_config for polling task, is_some: {}",
                channel_config.is_some()
            );
            let polling_config = self.polling_config.clone();
            let data_channel = self.data_channel.clone();
            let frame_processor = self.frame_processor.clone();

            let polling_task = tokio::spawn(async move {
                let mut interval =
                    tokio::time::interval(std::time::Duration::from_millis(polling_interval));

                info!(
                    "Polling task started for channel {}, interval {}ms",
                    channel_id, polling_interval
                );

                loop {
                    interval.tick().await;

                    // Check connection and attempt reconnection if needed
                    if !*is_connected.read().await {
                        debug!(
                            "Channel {} not connected, attempting reconnection...",
                            channel_id
                        );

                        // Check if reconnection is enabled (default: true)
                        if polling_config.reconnect_enabled {
                            let max_consecutive = polling_config.reconnect_max_consecutive;
                            let cooldown_ms = polling_config.reconnect_cooldown_ms;

                            // Attempt to reconnect (will handle retries and cooldown internally)
                            match connection_manager
                                .connect_with_retry(max_consecutive, cooldown_ms)
                                .await
                            {
                                Ok(true) => {
                                    // Successfully connected
                                    *is_connected.write().await = true;
                                    info!("Channel {} reconnected successfully", channel_id);
                                    // Continue with polling after successful reconnection
                                },
                                Ok(false) => {
                                    // In cooldown period or max attempts reached
                                    debug!("Channel {} reconnection in cooldown, will retry after cooldown", channel_id);
                                    continue;
                                },
                                Err(e) => {
                                    // Unexpected error
                                    error!("Channel {} reconnection error: {}", channel_id, e);
                                    continue;
                                },
                            }
                        } else {
                            debug!(
                                "Channel {} reconnection disabled, skipping poll",
                                channel_id
                            );
                            continue;
                        }
                    }

                    debug!("Executing poll for channel {}", channel_id);

                    // Group points by slave ID and function code for batch reading
                    // Process telemetry and signal points separately to ensure isolation
                    let grouped_points = {
                        let mut groups: HashMap<(u8, u8, String), Vec<ModbusPoint>> =
                            HashMap::new();

                        // Add telemetry points
                        let telemetry_guard = telemetry_points.read().await;
                        for point in telemetry_guard.iter() {
                            let key =
                                (point.slave_id, point.function_code, "telemetry".to_string());
                            groups.entry(key).or_default().push(point.clone());
                        }

                        // Add signal points
                        let signal_guard = signal_points.read().await;
                        for point in signal_guard.iter() {
                            let key = (point.slave_id, point.function_code, "signal".to_string());
                            groups.entry(key).or_default().push(point.clone());
                        }

                        if groups.is_empty() {
                            debug!("No points configured for channel {}", channel_id);
                            continue;
                        }

                        debug!("Processing {} groups for polling", groups.len());
                        groups
                    };

                    let mut success_count = 0;
                    let mut error_count = 0;

                    // Collect all telemetry and signal data for this poll cycle
                    let mut telemetry_batch = Vec::new();
                    let mut signal_batch = Vec::new();
                    let timestamp = chrono::Utc::now().timestamp();

                    // Read each group
                    for ((slave_id, function_code, group_telemetry_type), group_points) in
                        grouped_points
                    {
                        if group_points.is_empty() {
                            continue;
                        }

                        debug!(
                            "Reading {} {} points for slave {}, function {}",
                            group_points.len(),
                            group_telemetry_type,
                            slave_id,
                            function_code
                        );

                        // Lock the frame processor for this batch of reads
                        let mut frame_processor = frame_processor.lock().await;

                        // Get max_batch_size from polling config, default to 100
                        let max_batch_size = polling_config.batch_config.max_batch_size;

                        // Create channel logger for protocol messages
                        let logger =
                            crate::core::combase::traits::ChannelLogger::new(channel_id.into());

                        match read_modbus_group_with_processor(
                            &connection_manager,
                            &mut frame_processor,
                            slave_id,
                            function_code,
                            &group_points,
                            channel_config.as_deref(),
                            max_batch_size,
                            &logger,
                        )
                        .await
                        {
                            Ok(values) => {
                                success_count += values.len();

                                // Process values
                                debug!("Processing {} values from Modbus read", values.len());

                                for (point_id_str, value) in values {
                                    // Convert point_id from string to u32
                                    if let Ok(point_id) = point_id_str.parse::<u32>() {
                                        // Convert RedisValue to f64
                                        let raw_value = match value {
                                            RedisValue::Float(f) => f,
                                            RedisValue::Integer(i) => i as f64,
                                            _ => continue, // Skip non-numeric values
                                        };

                                        // Use the telemetry type from the group
                                        // This ensures proper four-telemetry isolation
                                        let telemetry_type = match group_telemetry_type.as_str() {
                                            "telemetry" => TelemetryType::Telemetry,
                                            "signal" => TelemetryType::Signal,
                                            _ => TelemetryType::Telemetry,
                                        };

                                        // Collect data for batch sending
                                        match telemetry_type {
                                            TelemetryType::Telemetry => {
                                                telemetry_batch
                                                    .push((point_id, raw_value, timestamp));
                                                debug!(
                                                    "Collected telemetry point {}: raw={:.6}",
                                                    point_id, raw_value
                                                );
                                            },
                                            TelemetryType::Signal => {
                                                signal_batch.push((point_id, raw_value, timestamp));
                                                debug!(
                                                    "Collected signal point {}: raw={:.6}",
                                                    point_id, raw_value
                                                );
                                            },
                                            TelemetryType::Control | TelemetryType::Adjustment => {
                                                // Control and adjustment data are not polled
                                                debug!(
                                                    "Skipping control/adjustment point {}",
                                                    point_id
                                                );
                                            },
                                        }
                                    }
                                }
                            },
                            Err(e) => {
                                error_count += group_points.len();
                                error!(
                                    "Failed to read modbus group (slave={}, func={}): {}",
                                    slave_id, function_code, e
                                );

                                // Check if this is a connection error
                                let error_str = e.to_string();
                                if error_str.contains("Broken pipe")
                                    || error_str.contains("Connection reset")
                                    || error_str.contains("Connection refused")
                                    || error_str.contains("TCP send error")
                                    || error_str.contains("TCP receive error")
                                {
                                    warn!("Connection lost during polling: {}", e);
                                    *is_connected.write().await = false;
                                    // Next iteration will trigger reconnection
                                    break; // Exit the group processing loop
                                }
                            },
                        }
                    }

                    // Send batch data through channel if available
                    if let Some(ref tx) = data_channel {
                        // Send batch if not empty
                        if !telemetry_batch.is_empty() || !signal_batch.is_empty() {
                            let batch = TelemetryBatch {
                                channel_id,
                                telemetry: telemetry_batch,
                                signal: signal_batch,
                            };

                            // Use send().await instead of try_send for guaranteed delivery
                            match tx.send(batch).await {
                                Ok(()) => {
                                    debug!("Sent telemetry batch for channel {} with immediate delivery", channel_id);
                                },
                                Err(e) => {
                                    error!(
                                        "Failed to send telemetry batch for channel {}: {}",
                                        channel_id, e
                                    );
                                },
                            }
                        }
                    }

                    info!(
                        "Poll completed for channel {}: {} success, {} errors",
                        channel_id, success_count, error_count
                    );

                    // Update status
                    let mut status_guard = status.write().await;
                    status_guard.last_update = chrono::Utc::now().timestamp();
                    status_guard.success_count += success_count as u64;
                    status_guard.error_count += error_count as u64;
                }
            });

            *self.polling_handle.write().await = Some(polling_task);
        }

        Ok(())
    }

    async fn stop_periodic_tasks(&self) -> Result<()> {
        info!(
            "Stopping Modbus periodic tasks for channel {}",
            self.channel_id
        );

        // Stop polling task
        if let Some(handle) = self.polling_handle.write().await.take() {
            handle.abort();
            info!("Polling task stopped for channel {}", self.channel_id);
        }

        Ok(())
    }

    fn set_data_channel(&mut self, tx: tokio::sync::mpsc::Sender<TelemetryBatch>) {
        self.data_channel = Some(tx);
        debug!("Data channel set for channel {}", self.channel_id);
    }

    fn set_command_receiver(&mut self, mut rx: tokio::sync::mpsc::Receiver<ChannelCommand>) {
        let channel_id = self.channel_id;
        let is_connected = self.is_connected.clone();
        let frame_processor = self.frame_processor.clone();
        let channel_config = self.channel_config.clone();
        let _command_handle = self.command_handle.clone();
        let connection_manager = self.connection_manager.clone();

        // Create a channel to forward commands for processing
        let (cmd_tx, mut cmd_rx) = tokio::sync::mpsc::channel::<(
            ChannelCommand,
            tokio::sync::oneshot::Sender<Result<()>>,
        )>(100);

        // Start command forwarding task
        tokio::spawn(async move {
            info!("Starting command receiver for channel {}", channel_id);
            while let Some(command) = rx.recv().await {
                let (tx, _rx) = tokio::sync::oneshot::channel();
                if let Err(e) = cmd_tx.send((command, tx)).await {
                    error!("Failed to forward command: {}", e);
                }
                // We don't wait for the result here
            }
            warn!("Command receiver stopped for channel {}", channel_id);
        });

        // Start command processing task
        let handle = tokio::spawn(async move {
            info!("Starting command processor for channel {}", channel_id);
            while let Some((command, result_tx)) = cmd_rx.recv().await {
                if !*is_connected.read().await {
                    warn!("Received command while disconnected, ignoring");
                    let _ = result_tx.send(Err(ComSrvError::NotConnected));
                    continue;
                }

                // Process command
                let result = match &command {
                    ChannelCommand::Control {
                        command_id,
                        point_id,
                        value,
                        ..
                    } => {
                        info!(
                            "Processing control command {}: point {}, value {}",
                            command_id, point_id, value
                        );

                        // Execute the control write
                        execute_modbus_write(
                            &connection_manager,
                            &frame_processor,
                            &channel_config,
                            *point_id,
                            RedisValue::Float(*value),
                            TelemetryType::Control,
                        )
                        .await
                    },
                    ChannelCommand::Adjustment {
                        command_id,
                        point_id,
                        value,
                        ..
                    } => {
                        info!(
                            "Processing adjustment command {}: point {}, value {}",
                            command_id, point_id, value
                        );

                        // Execute the adjustment write
                        execute_modbus_write(
                            &connection_manager,
                            &frame_processor,
                            &channel_config,
                            *point_id,
                            RedisValue::Float(*value),
                            TelemetryType::Adjustment,
                        )
                        .await
                    },
                };

                let _ = result_tx.send(result);
            }
            warn!("Command processor stopped for channel {}", channel_id);
        });

        // Store the command handle in a separate task to avoid blocking
        let command_handle = self.command_handle.clone();
        tokio::spawn(async move {
            let mut handle_guard = command_handle.write().await;
            *handle_guard = Some(handle);
        });

        debug!("Command receiver set for channel {}", self.channel_id);
    }
}

/// Read a group of Modbus points with the same slave ID and function code
async fn read_modbus_group_with_processor(
    connection_manager: &Arc<ModbusConnectionManager>,
    frame_processor: &mut ModbusFrameProcessor,
    slave_id: u8,
    function_code: u8,
    points: &[ModbusPoint],
    channel_config: Option<&ChannelConfig>,
    max_batch_size: u16,
    logger: &crate::core::combase::traits::ChannelLogger,
) -> Result<Vec<(String, RedisValue)>> {
    if points.is_empty() {
        return Ok(Vec::new());
    }

    // Sort points by register address for efficient batch reading
    let mut sorted_indices: Vec<usize> = (0..points.len()).collect();
    sorted_indices.sort_by_key(|&i| points[i].register_address);

    let mut results = Vec::new();
    let mut current_batch_indices = Vec::new();
    let mut batch_start_address = points[sorted_indices[0]].register_address;

    for &idx in &sorted_indices {
        let point = &points[idx];
        // Check if this point can be added to the current batch
        // For FC01/02, addresses are bit addresses; for FC03/04, they are register addresses
        let (gap, batch_size_if_added) = match function_code {
            1 | 2 => {
                // For coils/discrete inputs, addresses are consecutive bit addresses
                let expected_next_address = if current_batch_indices.is_empty() {
                    point.register_address
                } else {
                    batch_start_address + current_batch_indices.len() as u16
                };
                let gap = point.register_address.saturating_sub(expected_next_address);
                let batch_bits_if_added =
                    (point.register_address - batch_start_address + 1) as usize;
                (gap, batch_bits_if_added)
            },
            _ => {
                // For registers, use the original logic
                let gap = point.register_address.saturating_sub(
                    batch_start_address + current_batch_indices.len() as u16 * point.register_count,
                );
                let batch_end_if_added = point.register_address + point.register_count;
                let batch_registers_if_added = (batch_end_if_added - batch_start_address) as usize;
                (gap, batch_registers_if_added)
            },
        };

        // Check both gap and batch size constraints
        if current_batch_indices.is_empty()
            || (gap <= 5 && batch_size_if_added <= max_batch_size as usize)
        {
            current_batch_indices.push(idx);
        } else {
            // Read current batch using zero-copy indexed version
            let batch_results = read_modbus_batch_indexed(
                connection_manager,
                frame_processor,
                slave_id,
                function_code,
                batch_start_address,
                points,
                &current_batch_indices,
                channel_config,
                max_batch_size,
                logger,
            )
            .await?;
            results.extend(batch_results);

            // Start new batch
            current_batch_indices.clear();
            current_batch_indices.push(idx);
            batch_start_address = point.register_address;
        }
    }

    // Read final batch using zero-copy indexed version
    if !current_batch_indices.is_empty() {
        let batch_results = read_modbus_batch_indexed(
            connection_manager,
            frame_processor,
            slave_id,
            function_code,
            batch_start_address,
            points,
            &current_batch_indices,
            channel_config,
            max_batch_size,
            logger,
        )
        .await?;
        results.extend(batch_results);
    }

    Ok(results)
}

/// Read a batch of consecutive Modbus registers with zero-copy design
#[allow(clippy::too_many_arguments)]
async fn read_modbus_batch_indexed(
    connection_manager: &Arc<ModbusConnectionManager>,
    frame_processor: &mut ModbusFrameProcessor,
    slave_id: u8,
    function_code: u8,
    start_address: u16,
    all_points: &[ModbusPoint], // All points reference
    indices: &[usize],          // Indices of points to read
    _channel_config: Option<&ChannelConfig>,
    max_batch_size: u16,
    logger: &crate::core::combase::traits::ChannelLogger, // Add logger parameter
) -> Result<Vec<(String, RedisValue)>> {
    if indices.is_empty() {
        return Ok(Vec::new());
    }

    // Get the last point via index
    let last_point = &all_points[indices[indices.len() - 1]];

    // Calculate total registers/bits to read based on function code
    let (total_units, unit_name) = match function_code {
        1 | 2 => {
            let total_bits = (last_point.register_address - start_address + 1) as usize;
            (total_bits, "bits")
        },
        _ => {
            let total_registers =
                (last_point.register_address - start_address + last_point.register_count) as usize;
            (total_registers, "registers")
        },
    };

    // Collect all register values by reading in batches
    let mut all_register_values = Vec::new();
    let mut current_offset = 0;

    // Read registers/bits in chunks no larger than max_batch_size
    while current_offset < total_units {
        let (batch_size, batch_start) = match function_code {
            1 | 2 => {
                let remaining_bits = total_units - current_offset;
                let batch_bits = std::cmp::min(max_batch_size as usize, remaining_bits);
                let batch_start = start_address + current_offset as u16;
                (batch_bits, batch_start)
            },
            _ => {
                let batch_size =
                    std::cmp::min(max_batch_size as usize, total_units - current_offset);
                let batch_start = start_address + current_offset as u16;
                (batch_size, batch_start)
            },
        };

        debug!(
            "Reading Modbus batch: slave={}, func={}, start={}, count={} {} (offset={}/{})",
            slave_id,
            function_code,
            batch_start,
            batch_size,
            unit_name,
            current_offset,
            total_units
        );

        // Build Modbus PDU for this batch
        let pdu = match function_code {
            1 => build_read_fc01_coils_pdu(batch_start, batch_size as u16)?,
            2 => build_read_fc02_discrete_inputs_pdu(batch_start, batch_size as u16)?,
            3 => build_read_fc03_holding_registers_pdu(batch_start, batch_size as u16)?,
            4 => build_read_fc04_input_registers_pdu(batch_start, batch_size as u16)?,
            _ => {
                return Err(ComSrvError::ProtocolError(format!(
                    "Unsupported function code: {function_code}"
                )))
            },
        };

        debug!(
            "Built PDU for batch_start={}, batch_size={}, PDU bytes: {:02X?}",
            batch_start,
            batch_size,
            pdu.as_slice()
        );

        // Build complete frame with proper header (MBAP for TCP, CRC for RTU)
        let request = frame_processor.build_frame(slave_id, &pdu);

        // Log outgoing request
        logger.log_protocol_message(
            "TX",
            &request,
            &format!(
                "Modbus FC{} request: slave={}, addr={}, count={}",
                function_code, slave_id, batch_start, batch_size
            ),
        );

        // Send request and wait for the correct response
        let mut retry_count = 0;
        const MAX_RETRIES: u32 = 3;
        let batch_register_values = loop {
            let mut response = vec![0u8; 256];
            let bytes_read = connection_manager
                .send_and_receive(&request, &mut response, Duration::from_secs(5))
                .await?;
            response.truncate(bytes_read);

            // Log incoming response
            logger.log_protocol_message(
                "RX",
                &response,
                &format!("Modbus FC{} response: {} bytes", function_code, bytes_read),
            );

            match frame_processor.parse_frame(&response) {
                Ok((received_unit_id, pdu)) => {
                    if received_unit_id != slave_id {
                        return Err(ComSrvError::ProtocolError(format!(
                            "Unit ID mismatch: expected {slave_id}, got {received_unit_id}"
                        )));
                    }

                    debug!(
                        "Received PDU for FC{}: bytes={:02X?}",
                        function_code,
                        pdu.as_slice()
                    );

                    match parse_modbus_pdu(&pdu, function_code, batch_size as u16) {
                        Ok(values) => {
                            debug!(
                                "Parsed {} register values from PDU: {:?}",
                                values.len(),
                                values
                            );
                            break values;
                        },
                        Err(e) => {
                            error!("Failed to parse Modbus PDU: {}", e);
                            retry_count += 1;
                            if retry_count >= MAX_RETRIES {
                                return Err(e);
                            }
                            tokio::time::sleep(Duration::from_millis(100)).await;
                        },
                    }
                },
                Err(e) => {
                    debug!("Ignoring mismatched response: {}", e);
                    retry_count += 1;
                    if retry_count >= MAX_RETRIES {
                        return Err(ComSrvError::TimeoutError(
                            "Failed to get matching response after retries".to_string(),
                        ));
                    }
                    tokio::time::sleep(Duration::from_millis(100)).await;
                },
            }
        };

        // Verify received data size
        match function_code {
            1 | 2 => {
                let expected_bytes = (batch_size + 7) / 8;
                if batch_register_values.len() != expected_bytes {
                    warn!(
                        "Received {} bytes, expected {} bytes for {} bits at address {}",
                        batch_register_values.len(),
                        expected_bytes,
                        batch_size,
                        batch_start
                    );
                }
            },
            _ => {
                if batch_register_values.len() != batch_size {
                    warn!(
                        "Received {} registers, expected {} for batch at address {}",
                        batch_register_values.len(),
                        batch_size,
                        batch_start
                    );
                }
            },
        };

        all_register_values.extend(batch_register_values);
        current_offset += batch_size;
    }

    // Extract values for each point from the complete register collection using indices
    let mut results = Vec::new();
    for &idx in indices {
        let point = &all_points[idx];

        // Handle different addressing for coils/discrete inputs vs registers
        let (registers, bit_position_override) = match function_code {
            1 | 2 => {
                let bit_address = point.register_address - start_address;
                let byte_offset = (bit_address / 8) as usize;
                let bit_offset = bit_address % 8;

                if byte_offset >= all_register_values.len() {
                    warn!(
                        "Point {} with bit address {} is out of range",
                        point.point_id, point.register_address
                    );
                    continue;
                }

                let single_byte = vec![all_register_values[byte_offset]];
                (single_byte, Some(bit_offset as u8))
            },
            _ => {
                let offset = (point.register_address - start_address) as usize;
                let register_count = point.register_count as usize;

                if offset + register_count > all_register_values.len() {
                    warn!(
                        "Point {} at register {} is out of range",
                        point.point_id, point.register_address
                    );
                    continue;
                }

                let registers = all_register_values[offset..offset + register_count].to_vec();
                // For bool types reading from holding registers, use the configured bit_position
                let bit_position_override = if point.data_type == "bool" {
                    point.bit_position
                } else {
                    None
                };
                (registers, bit_position_override)
            },
        };

        // Parse value based on data type
        let value = decode_register_value(
            &registers,
            &point.data_type,
            bit_position_override,
            point.byte_order.as_deref(),
            Some(function_code),
        )?;

        // Convert raw register data to bytes for logging
        let mut raw_bytes = Vec::new();
        for reg in &registers {
            raw_bytes.extend_from_slice(&reg.to_be_bytes());
        }

        // Log parsed data to channel log
        let value_str = match &value {
            RedisValue::Float(f) => format!("{}", f),
            RedisValue::Integer(i) => format!("{}", i),
            RedisValue::Bool(b) => format!("{}", b),
            RedisValue::String(s) => s.to_string(),
            RedisValue::Null => "null".to_string(),
        };
        logger.log_parsed_data(&point.point_id, &value_str, &raw_bytes);

        results.push((point.point_id.clone(), value));
    }

    Ok(results)
}

/// Build Modbus PDU for FC05: Write Single Coil
fn build_write_fc05_single_coil_pdu(address: u16, value: bool) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x05)?
        .address(address)?
        .byte(if value { 0xFF } else { 0x00 })?  // 0xFF00 for ON, 0x0000 for OFF
        .byte(0x00)?
        .build())
}

/// Build Modbus PDU for FC06: Write Single Register
fn build_write_fc06_single_register_pdu(address: u16, value: u16) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x06)?
        .address(address)?
        .quantity(value)?
        .build())
}

/// Build Modbus PDU for FC15: Write Multiple Coils
fn build_write_fc15_multiple_coils_pdu(start_address: u16, values: &[bool]) -> Result<ModbusPdu> {
    let quantity = values.len() as u16;
    let byte_count = quantity.div_ceil(8) as u8;

    let mut pdu = ModbusPdu::new();
    pdu.push(0x0F)?; // Function code 15: Write Multiple Coils
    pdu.push_u16(start_address)?;
    pdu.push_u16(quantity)?;
    pdu.push(byte_count)?;

    // Pack bool values into bytes
    let mut byte_value = 0u8;
    for (i, &value) in values.iter().enumerate() {
        if value {
            byte_value |= 1 << (i % 8);
        }
        if (i + 1) % 8 == 0 || i == values.len() - 1 {
            pdu.push(byte_value)?;
            byte_value = 0;
        }
    }

    Ok(pdu)
}

/// Build Modbus PDU for FC16: Write Multiple Registers
fn build_write_fc16_multiple_registers_pdu(
    start_address: u16,
    values: &[u16],
) -> Result<ModbusPdu> {
    let quantity = values.len() as u16;
    let byte_count = (quantity * 2) as u8;

    let mut pdu = ModbusPdu::new();
    pdu.push(0x10)?; // Function code 16: Write Multiple Registers
    pdu.push_u16(start_address)?;
    pdu.push_u16(quantity)?;
    pdu.push(byte_count)?;

    // Add register values (big-endian)
    for &value in values {
        pdu.push_u16(value)?;
    }

    Ok(pdu)
}

/// Build Modbus PDU for FC01: Read Coils
fn build_read_fc01_coils_pdu(start_address: u16, quantity: u16) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x01)?
        .address(start_address)?
        .quantity(quantity)?
        .build())
}

/// Build Modbus PDU for FC02: Read Discrete Inputs
fn build_read_fc02_discrete_inputs_pdu(start_address: u16, quantity: u16) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x02)?
        .address(start_address)?
        .quantity(quantity)?
        .build())
}

/// Build Modbus PDU for FC03: Read Holding Registers
fn build_read_fc03_holding_registers_pdu(start_address: u16, quantity: u16) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x03)?
        .address(start_address)?
        .quantity(quantity)?
        .build())
}

/// Build Modbus PDU for FC04: Read Input Registers
fn build_read_fc04_input_registers_pdu(start_address: u16, quantity: u16) -> Result<ModbusPdu> {
    Ok(PduBuilder::new()
        .function_code(0x04)?
        .address(start_address)?
        .quantity(quantity)?
        .build())
}

/// Parse Modbus write response PDU
fn parse_modbus_write_response(pdu: &ModbusPdu, expected_fc: u8) -> Result<bool> {
    if pdu.is_empty() {
        return Err(ComSrvError::ProtocolError("Empty PDU response".to_string()));
    }

    let function_code = pdu.function_code().unwrap_or(0);

    // Check for exception response
    if pdu.is_exception() {
        let exception_code = pdu.exception_code().unwrap_or(0);
        let error_msg = match exception_code {
            1 => "Illegal function",
            2 => "Illegal data address",
            3 => "Illegal data value",
            4 => "Slave device failure",
            _ => "Unknown exception",
        };
        return Err(ComSrvError::ProtocolError(format!(
            "Modbus exception {}: {}",
            exception_code, error_msg
        )));
    }

    // Check normal response
    if function_code != expected_fc {
        return Err(ComSrvError::ProtocolError(format!(
            "Function code mismatch: expected {}, got {}",
            expected_fc, function_code
        )));
    }

    // For write functions, the response echoes the request
    match expected_fc {
        5 | 6 => {
            // FC05/06: Response should be 5 bytes (FC + address + value)
            if pdu.len() >= 5 {
                Ok(true)
            } else {
                Err(ComSrvError::ProtocolError(
                    "Incomplete write response".to_string(),
                ))
            }
        },
        15 | 16 => {
            // FC15/16: Response should be 5 bytes (FC + address + quantity)
            if pdu.len() >= 5 {
                Ok(true)
            } else {
                Err(ComSrvError::ProtocolError(
                    "Incomplete write response".to_string(),
                ))
            }
        },
        _ => Err(ComSrvError::ProtocolError(format!(
            "Unsupported write function code: {}",
            expected_fc
        ))),
    }
}

/// Encode RedisValue to register values based on data type
fn encode_value_for_modbus(
    value: &RedisValue,
    data_type: &str,
    byte_order: Option<&str>,
) -> Result<Vec<u16>> {
    match data_type {
        "bool" => {
            let bool_value = match value {
                RedisValue::Integer(i) => *i != 0,
                RedisValue::Float(f) => *f != 0.0,
                _ => {
                    return Err(ComSrvError::ProtocolError(
                        "Invalid value type for bool".to_string(),
                    ))
                },
            };
            // For bool, return 1 or 0 as u16
            Ok(vec![if bool_value { 1 } else { 0 }])
        },
        "uint16" => {
            let int_value = match value {
                RedisValue::Integer(i) => *i as u16,
                RedisValue::Float(f) => *f as u16,
                _ => {
                    return Err(ComSrvError::ProtocolError(
                        "Invalid value type for uint16".to_string(),
                    ))
                },
            };
            Ok(vec![int_value])
        },
        "int16" => {
            let int_value = match value {
                RedisValue::Integer(i) => *i as i16,
                RedisValue::Float(f) => *f as i16,
                _ => {
                    return Err(ComSrvError::ProtocolError(
                        "Invalid value type for int16".to_string(),
                    ))
                },
            };
            Ok(vec![int_value as u16])
        },
        "uint32" | "int32" => {
            let int_value = match value {
                RedisValue::Integer(i) => *i as u32,
                RedisValue::Float(f) => *f as u32,
                _ => {
                    return Err(ComSrvError::ProtocolError(
                        "Invalid value type for 32-bit int".to_string(),
                    ))
                },
            };

            // Apply byte order conversion
            let bytes = int_value.to_be_bytes();
            let registers = convert_bytes_to_registers_with_order(&bytes, byte_order);
            Ok(registers)
        },
        "float32" => {
            let float_value = match value {
                RedisValue::Float(f) => *f as f32,
                RedisValue::Integer(i) => *i as f32,
                _ => {
                    return Err(ComSrvError::ProtocolError(
                        "Invalid value type for float32".to_string(),
                    ))
                },
            };

            let bytes = float_value.to_be_bytes();
            let registers = convert_bytes_to_registers_with_order(&bytes, byte_order);
            Ok(registers)
        },
        _ => Err(ComSrvError::ProtocolError(format!(
            "Unsupported data type for writing: {}",
            data_type
        ))),
    }
}

/// Convert bytes to registers with byte order
fn convert_bytes_to_registers_with_order(bytes: &[u8], byte_order: Option<&str>) -> Vec<u16> {
    if bytes.len() < 4 {
        // For 2-byte values
        if bytes.len() >= 2 {
            return vec![((bytes[0] as u16) << 8) | (bytes[1] as u16)];
        }
        return vec![];
    }

    match byte_order {
        Some("ABCD") | None => {
            // Big endian (default)
            vec![
                ((bytes[0] as u16) << 8) | (bytes[1] as u16),
                ((bytes[2] as u16) << 8) | (bytes[3] as u16),
            ]
        },
        Some("DCBA") => {
            // Little endian
            vec![
                ((bytes[3] as u16) << 8) | (bytes[2] as u16),
                ((bytes[1] as u16) << 8) | (bytes[0] as u16),
            ]
        },
        Some("BADC") => {
            // Swap bytes within registers
            vec![
                ((bytes[1] as u16) << 8) | (bytes[0] as u16),
                ((bytes[3] as u16) << 8) | (bytes[2] as u16),
            ]
        },
        Some("CDAB") => {
            // Swap register order
            vec![
                ((bytes[2] as u16) << 8) | (bytes[3] as u16),
                ((bytes[0] as u16) << 8) | (bytes[1] as u16),
            ]
        },
        _ => {
            // Default to big endian
            vec![
                ((bytes[0] as u16) << 8) | (bytes[1] as u16),
                ((bytes[2] as u16) << 8) | (bytes[3] as u16),
            ]
        },
    }
}

/// Execute Modbus write command for control or adjustment points
async fn execute_modbus_write(
    connection_manager: &Arc<ModbusConnectionManager>,
    frame_processor: &Arc<Mutex<ModbusFrameProcessor>>,
    channel_config: &Option<Arc<ChannelConfig>>,
    point_id: u32,
    value: RedisValue,
    telemetry_type: TelemetryType,
) -> Result<()> {
    // Get the point configuration from channel config based on telemetry type
    let point_config = if let Some(config) = channel_config {
        match telemetry_type {
            TelemetryType::Control => config.control_points.get(&point_id),
            TelemetryType::Adjustment => config.adjustment_points.get(&point_id),
            _ => None,
        }
    } else {
        None
    };

    let point_config = match point_config {
        Some(p) => p,
        None => {
            return Err(ComSrvError::InvalidData(format!(
                "Point {} not found in {} configuration",
                point_id,
                match telemetry_type {
                    TelemetryType::Control => "control",
                    TelemetryType::Adjustment => "adjustment",
                    _ => "unknown",
                }
            )));
        },
    };

    // Extract Modbus parameters from protocol_params
    let slave_id = point_config
        .protocol_params
        .get("slave_id")
        .and_then(|s| s.parse::<u8>().ok())
        .unwrap_or(1);

    let function_code = point_config
        .protocol_params
        .get("function_code")
        .and_then(|s| s.parse::<u8>().ok())
        .unwrap_or(6); // Default to FC6 for single register write

    let register_address = point_config
        .protocol_params
        .get("register_address")
        .and_then(|s| s.parse::<u16>().ok())
        .ok_or_else(|| ComSrvError::InvalidData("Missing register_address".to_string()))?;

    let data_type = point_config
        .protocol_params
        .get("data_type")
        .cloned()
        .unwrap_or_else(|| "float32".to_string());

    let byte_order = point_config.protocol_params.get("byte_order").cloned();

    debug!(
        "Writing to Modbus: slave={}, func={}, addr={}, type={}, value={:?}",
        slave_id, function_code, register_address, data_type, value
    );

    // Convert value to register format
    let registers = encode_value_for_modbus(&value, &data_type, byte_order.as_deref())?;

    // Build the appropriate write PDU based on function code
    let pdu = match function_code {
        5 => {
            // Write Single Coil
            let bool_value = match value {
                RedisValue::Integer(i) => i != 0,
                RedisValue::Float(f) => f != 0.0,
                _ => false,
            };
            build_write_fc05_single_coil_pdu(register_address, bool_value)?
        },
        6 => {
            // Write Single Register
            if registers.is_empty() {
                return Err(ComSrvError::InvalidData(
                    "No register value to write".to_string(),
                ));
            }
            build_write_fc06_single_register_pdu(register_address, registers[0])?
        },
        15 => {
            // Write Multiple Coils - for now just write single coil
            let bool_value = match value {
                RedisValue::Integer(i) => i != 0,
                RedisValue::Float(f) => f != 0.0,
                _ => false,
            };
            build_write_fc15_multiple_coils_pdu(register_address, &[bool_value])?
        },
        16 => {
            // Write Multiple Registers
            build_write_fc16_multiple_registers_pdu(register_address, &registers)?
        },
        _ => {
            return Err(ComSrvError::ProtocolError(format!(
                "Unsupported write function code: {}",
                function_code
            )));
        },
    };

    // Get frame processor lock
    let mut frame_processor_guard = frame_processor.lock().await;

    // Build complete frame with proper header
    let request = frame_processor_guard.build_frame(slave_id, &pdu);

    // Send request and wait for response
    let mut response = vec![0u8; 256];
    let bytes_read = connection_manager
        .send_and_receive(&request, &mut response, Duration::from_secs(5))
        .await?;
    response.truncate(bytes_read);

    // Parse response frame
    let (received_unit_id, response_pdu) = frame_processor_guard.parse_frame(&response)?;

    // Verify unit ID matches
    if received_unit_id != slave_id {
        return Err(ComSrvError::ProtocolError(format!(
            "Unit ID mismatch in write response: expected {}, got {}",
            slave_id, received_unit_id
        )));
    }

    // Parse write response
    parse_modbus_write_response(&response_pdu, function_code)?;

    info!(
        "Successfully wrote value {:?} to point {} (addr={}, slave={})",
        value, point_id, register_address, slave_id
    );

    Ok(())
}

/// Parse Modbus PDU and extract register values
/// For FC 01/02: returns bytes as u16 values (one byte per u16)
/// For FC 03/04: returns actual 16-bit register values
fn parse_modbus_pdu(pdu: &ModbusPdu, function_code: u8, expected_count: u16) -> Result<Vec<u16>> {
    let pdu_data = pdu.as_slice();

    if pdu_data.len() < 3 {
        return Err(ComSrvError::ProtocolError("PDU too short".to_string()));
    }

    let actual_fc = pdu.function_code().unwrap_or(0);
    if actual_fc != function_code {
        return Err(ComSrvError::ProtocolError(format!(
            "Function code mismatch: expected {}, got {}",
            function_code, actual_fc
        )));
    }

    let byte_count = pdu_data[1] as usize;
    if pdu_data.len() < 2 + byte_count {
        return Err(ComSrvError::ProtocolError(
            "Incomplete PDU data".to_string(),
        ));
    }

    // Validate byte count based on function code
    match function_code {
        1 | 2 => {
            // FC 01/02: byte_count should be ceil(coil_count / 8)
            let expected_bytes = ((expected_count + 7) / 8) as usize;
            if byte_count != expected_bytes {
                return Err(ComSrvError::ProtocolError(format!(
                    "Byte count mismatch for FC{:02}: expected {} bytes for {} coils, got {}",
                    function_code, expected_bytes, expected_count, byte_count
                )));
            }

            // Return bytes as-is (each byte stored in a u16 for uniform processing)
            let mut registers = Vec::new();
            for &byte in &pdu_data[2..2 + byte_count] {
                registers.push(u16::from(byte));
            }
            Ok(registers)
        },
        3 | 4 => {
            // FC 03/04: byte_count should be register_count * 2
            let expected_bytes = (expected_count * 2) as usize;
            if byte_count != expected_bytes {
                return Err(ComSrvError::ProtocolError(format!(
                    "Byte count mismatch for FC{:02}: expected {} bytes for {} registers, got {}",
                    function_code, expected_bytes, expected_count, byte_count
                )));
            }

            // Parse 16-bit registers
            let mut registers = Vec::new();
            for i in (2..2 + byte_count).step_by(2) {
                let value = (u16::from(pdu_data[i]) << 8) | u16::from(pdu_data[i + 1]);
                registers.push(value);
            }
            Ok(registers)
        },
        _ => Err(ComSrvError::ProtocolError(format!(
            "Unsupported function code in PDU parsing: {function_code}"
        ))),
    }
}

/// Convert registers to bytes with specified byte order
fn convert_registers_with_byte_order(registers: &[u16], byte_order: Option<&str>) -> Vec<u8> {
    let mut bytes = Vec::new();

    // Convert registers to bytes (default: ABCD - big endian)
    for &reg in registers {
        bytes.push((reg >> 8) as u8); // High byte (A)
        bytes.push((reg & 0xFF) as u8); // Low byte (B)
    }

    match byte_order {
        Some("ABCD") | None => bytes, // Big endian (default)
        Some("DCBA") => {
            // Reverse all bytes for complete little endian
            // For float64 (8 bytes): reverse all 8 bytes
            // For float32/uint32/int32 (4 bytes): reverse all 4 bytes
            // For uint16/int16 (2 bytes): reverse the 2 bytes
            let mut reversed = bytes.clone();
            reversed.reverse();
            reversed
        },
        Some("BADC") => {
            // Swap bytes within each register: ABCD -> BADC
            // For 8 bytes (float64): ABCDEFGH -> BADCFEHG
            // For 4 bytes (float32/int32/uint32): ABCD -> BADC
            let mut result = Vec::new();
            for chunk in bytes.chunks(2) {
                if chunk.len() == 2 {
                    result.push(chunk[1]); // Second byte
                    result.push(chunk[0]); // First byte
                } else {
                    result.extend_from_slice(chunk);
                }
            }
            result
        },
        Some("CDAB") => {
            // Swap register order (16-bit words): ABCD -> CDAB
            // For 8 bytes (float64): ABCDEFGH -> CDEFABGH
            // For 4 bytes (float32/int32/uint32): ABCD -> CDAB
            let mut result = Vec::new();
            for chunk in bytes.chunks(4) {
                if chunk.len() == 4 {
                    result.push(chunk[2]); // C
                    result.push(chunk[3]); // D
                    result.push(chunk[0]); // A
                    result.push(chunk[1]); // B
                } else {
                    result.extend_from_slice(chunk);
                }
            }
            result
        },
        Some("BA") => {
            // For int16: AB -> BA
            if bytes.len() >= 2 {
                let mut result = Vec::new();
                for chunk in bytes.chunks(2) {
                    if chunk.len() == 2 {
                        result.push(chunk[1]); // B
                        result.push(chunk[0]); // A
                    } else {
                        result.extend_from_slice(chunk);
                    }
                }
                result
            } else {
                bytes
            }
        },
        Some("AB") => bytes, // Same as default
        _ => {
            debug!("Unknown byte order: {:?}, using default ABCD", byte_order);
            bytes
        },
    }
}

/// Decode register values based on data format
fn decode_register_value(
    registers: &[u16],
    format: &str,
    bit_position: Option<u8>,
    byte_order: Option<&str>,
    function_code: Option<u8>,
) -> Result<RedisValue> {
    match format {
        "bool" => {
            if registers.is_empty() {
                return Err(ComSrvError::ProtocolError(
                    "No registers for bool".to_string(),
                ));
            }

            // Use Modbus 1-based bit numbering
            // Default to bit 1 (not 0) per Modbus convention
            let bit_pos = bit_position.unwrap_or(1);

            // Determine if this is from coils/discrete inputs (FC 01/02) or registers (FC 03/04)
            let is_coil_response = matches!(function_code, Some(1) | Some(2));

            // All use 1-8 bit numbering per byte (Modbus convention)
            if !(1..=8).contains(&bit_pos) {
                return Err(ComSrvError::ProtocolError(format!(
                    "Invalid bit position: {} (must be 1-8)",
                    bit_pos
                )));
            }

            // Convert 1-based to 0-based for bit shifting
            let actual_bit = bit_pos - 1;

            if is_coil_response {
                // FC 01/02: Single byte
                let byte_value = registers[0] as u8;
                let bit_value = (byte_value >> actual_bit) & 0x01;

                debug!(
                    "Coil bit extraction: byte=0x{:02X}, bit_pos={} (0-based: {}), bit_value={}",
                    byte_value, bit_pos, actual_bit, bit_value
                );

                Ok(RedisValue::Integer(i64::from(bit_value)))
            } else {
                // FC 03/04: 16-bit register treated as bytes
                // For a 16-bit register: Low byte = bits 1-8, High byte would need separate handling
                let register_value = registers[0];

                // Extract from low byte (bits 1-8 of register)
                let byte_value = (register_value & 0xFF) as u8;
                let bit_value = (byte_value >> actual_bit) & 0x01;

                debug!(
                    "Register bit extraction: register=0x{:04X}, low_byte=0x{:02X}, bit_pos={} (0-based: {}), bit_value={}",
                    register_value, byte_value, bit_pos, actual_bit, bit_value
                );

                Ok(RedisValue::Integer(i64::from(bit_value)))
            }
        },
        "uint16" => {
            if registers.is_empty() {
                return Err(ComSrvError::ProtocolError(
                    "No registers for uint16".to_string(),
                ));
            }
            Ok(RedisValue::Integer(i64::from(registers[0])))
        },
        "int16" => {
            if registers.is_empty() {
                return Err(ComSrvError::ProtocolError(
                    "No registers for int16".to_string(),
                ));
            }
            let bytes = convert_registers_with_byte_order(registers, byte_order);
            if bytes.len() >= 2 {
                let value = i16::from_be_bytes([bytes[0], bytes[1]]);
                Ok(RedisValue::Integer(i64::from(value)))
            } else {
                Ok(RedisValue::Integer(i64::from(registers[0] as i16)))
            }
        },
        "uint32" | "uint32_be" => {
            if registers.len() < 2 {
                return Err(ComSrvError::ProtocolError(
                    "Not enough registers for uint32".to_string(),
                ));
            }
            let bytes = convert_registers_with_byte_order(registers, byte_order);
            if bytes.len() >= 4 {
                let value = u32::from_be_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
                Ok(RedisValue::Integer(i64::from(value)))
            } else {
                // Fallback to old method if bytes conversion fails
                let value = (u32::from(registers[0]) << 16) | u32::from(registers[1]);
                Ok(RedisValue::Integer(i64::from(value)))
            }
        },
        "int32" | "int32_be" => {
            if registers.len() < 2 {
                return Err(ComSrvError::ProtocolError(
                    "Not enough registers for int32".to_string(),
                ));
            }
            let bytes = convert_registers_with_byte_order(registers, byte_order);
            if bytes.len() >= 4 {
                let value = i32::from_be_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
                Ok(RedisValue::Integer(i64::from(value)))
            } else {
                // Fallback to old method if bytes conversion fails
                let value = (i32::from(registers[0]) << 16) | i32::from(registers[1]);
                Ok(RedisValue::Integer(i64::from(value)))
            }
        },
        "float32" | "float32_be" | "float" => {
            if registers.len() < 2 {
                return Err(ComSrvError::ProtocolError(
                    "Not enough registers for float32".to_string(),
                ));
            }

            // Special handling for DCBA - the simulator stores bytes in little-endian order directly
            let (bytes, value) = if byte_order == Some("DCBA") {
                // For DCBA, extract bytes directly from registers (they're already in little-endian order)
                let mut bytes = Vec::new();
                for &reg in &registers[0..2] {
                    bytes.push((reg >> 8) as u8); // High byte of register
                    bytes.push((reg & 0xFF) as u8); // Low byte of register
                }
                // Bytes are already in little-endian order, decode with from_le_bytes
                let value = f32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
                (bytes, value)
            } else {
                // For other byte orders, use the standard conversion
                let bytes = convert_registers_with_byte_order(registers, byte_order);
                if bytes.len() >= 4 {
                    let value = f32::from_be_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
                    (bytes[0..4].to_vec(), value)
                } else {
                    // Fallback to direct conversion if not enough bytes
                    let bytes = vec![
                        (registers[0] >> 8) as u8,
                        (registers[0] & 0xFF) as u8,
                        (registers[1] >> 8) as u8,
                        (registers[1] & 0xFF) as u8,
                    ];
                    let value = f32::from_be_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
                    (bytes, value)
                }
            };

            info!(
                "Float32 conversion: registers={:?}, byte_order={:?}, bytes={:02X?}, value={}",
                registers,
                byte_order,
                &bytes[0..4],
                value
            );
            Ok(RedisValue::Float(f64::from(value)))
        },
        "float64" | "float64_be" | "double" => {
            if registers.len() < 4 {
                return Err(ComSrvError::ProtocolError(
                    "Not enough registers for float64".to_string(),
                ));
            }

            // Special handling for DCBA - the simulator stores bytes in little-endian order directly
            let (bytes, value) = if byte_order == Some("DCBA") {
                // For DCBA, extract bytes directly from registers (they're already in little-endian order)
                let mut bytes = Vec::new();
                for &reg in &registers[0..4] {
                    bytes.push((reg >> 8) as u8); // High byte of register
                    bytes.push((reg & 0xFF) as u8); // Low byte of register
                }
                // Bytes are already in little-endian order, decode with from_le_bytes
                let value = f64::from_le_bytes([
                    bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
                ]);
                (bytes, value)
            } else {
                // For other byte orders, use the standard conversion
                let bytes = convert_registers_with_byte_order(registers, byte_order);
                let value = f64::from_be_bytes([
                    bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
                ]);
                (bytes, value)
            };

            info!(
                "Float64 conversion: registers={:?}, byte_order={:?}, bytes={:02X?}, value={}",
                registers,
                byte_order,
                &bytes[0..8],
                value
            );
            Ok(RedisValue::Float(value))
        },
        _ => Err(ComSrvError::ProtocolError(format!(
            "Unsupported data format: {format}"
        ))),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::data_processor;

    // Helper function for tests
    fn telemetry_type_from_string(s: &str) -> TelemetryType {
        match s {
            "Telemetry" => TelemetryType::Telemetry,
            "Signal" => TelemetryType::Signal,
            "Control" => TelemetryType::Control,
            "Adjustment" => TelemetryType::Adjustment,
            _ => TelemetryType::Telemetry, // Default
        }
    }

    #[test]
    fn test_telemetry_type_from_string() {
        assert_eq!(
            telemetry_type_from_string("Telemetry"),
            TelemetryType::Telemetry
        );
        assert_eq!(telemetry_type_from_string("Signal"), TelemetryType::Signal);
        assert_eq!(
            telemetry_type_from_string("Control"),
            TelemetryType::Control
        );
        assert_eq!(
            telemetry_type_from_string("Adjustment"),
            TelemetryType::Adjustment
        );
        assert_eq!(
            telemetry_type_from_string("Unknown"),
            TelemetryType::Telemetry
        );
    }

    #[test]
    fn test_decode_register_value_bool_bitwise() {
        // Testing bit extraction with 1-based numbering (Modbus convention)

        // Test case 1: Register value 0xB5 = 181 = 10110101 in binary
        let register_value = 0xB5;
        let registers = vec![register_value];

        // For FC 03/04 (registers), use 1-16 bit numbering
        // Bit 1 (LSB) = 1
        let result = decode_register_value(&registers, "bool", Some(1), None, Some(3))
            .expect("decoding bit 1 should succeed");
        assert_eq!(result, RedisValue::Integer(1));

        // Bit 2 = 0
        let result = decode_register_value(&registers, "bool", Some(2), None, Some(3))
            .expect("decoding bit 2 should succeed");
        assert_eq!(result, RedisValue::Integer(0));

        // Bit 3 = 1
        let result = decode_register_value(&registers, "bool", Some(3), None, Some(3))
            .expect("decoding bit 3 should succeed");
        assert_eq!(result, RedisValue::Integer(1));

        // Bit 8 = 1
        let result = decode_register_value(&registers, "bool", Some(8), None, Some(3))
            .expect("decoding bit 8 should succeed");
        assert_eq!(result, RedisValue::Integer(1));

        // Test that only bits 1-8 are valid for registers now
        let high_bit_register = 0x0080; // Bit 8 of low byte set
        let high_registers = vec![high_bit_register];
        let result = decode_register_value(&high_registers, "bool", Some(8), None, Some(3))
            .expect("decoding bit 8 should succeed");
        assert_eq!(result, RedisValue::Integer(1));

        // Test FC 01/02 (coils) - uses 1-8 bit numbering
        let coil_byte = 0xB5; // Same value but treated as byte
        let coil_registers = vec![coil_byte];

        // Bit 1 (LSB) = 1
        let result = decode_register_value(&coil_registers, "bool", Some(1), None, Some(1))
            .expect("decoding coil bit 1 should succeed");
        assert_eq!(result, RedisValue::Integer(1));

        // Bit 8 (MSB of byte) = 1
        let result = decode_register_value(&coil_registers, "bool", Some(8), None, Some(1))
            .expect("decoding coil bit 8 should succeed");
        assert_eq!(result, RedisValue::Integer(1));
    }

    #[test]
    fn test_decode_register_value_bool_edge_cases() {
        let registers = vec![0x0000]; // All-zero register

        // Testing FC 01/02 (coils) - 1-8 bit numbering
        for bit_pos in 1..=8 {
            let result = decode_register_value(&registers, "bool", Some(bit_pos), None, Some(1));
            if let Ok(value) = result {
                assert_eq!(value, RedisValue::Integer(0), "Bit {} should be 0", bit_pos);
            } else {
                panic!("Failed to decode bit {}", bit_pos);
            }
        }

        // Testing FC 03/04 (registers) - 1-16 bit numbering
        let registers_16bit = vec![0x0100]; // 256 > 255, trigger 16-bit pattern
                                            // 0x0100 in binary: 0000 0001 0000 0000, only bit 9 is set
        for bit_pos in 1..=8 {
            let result =
                decode_register_value(&registers_16bit, "bool", Some(bit_pos), None, Some(3));
            let expected = if bit_pos == 9 { 1 } else { 0 }; // Only bit 9 is set
            if let Ok(value) = result {
                assert_eq!(
                    value,
                    RedisValue::Integer(expected),
                    "Bit {} should be {}",
                    bit_pos,
                    expected
                );
            } else {
                panic!("Failed to decode bit {}", bit_pos);
            }
        }

        let registers_all_ones = vec![0xFFFF]; // All 1s register
        for bit_pos in 1..=8 {
            let result =
                decode_register_value(&registers_all_ones, "bool", Some(bit_pos), None, Some(3));
            if let Ok(value) = result {
                assert_eq!(value, RedisValue::Integer(1), "Bit {} should be 1", bit_pos);
            } else {
                panic!("Failed to decode bit {}", bit_pos);
            }
        }

        // Testing error case: Bit 1 should be valid for registers (FC 03)
        let result = decode_register_value(&registers, "bool", Some(1), None, Some(3));
        assert!(
            result.is_ok(),
            "Bit position 1 should be valid for registers"
        );

        // Testing error case: bit position out of range for 16-bit mode
        let registers_16bit = vec![0x0100];
        let result = decode_register_value(&registers_16bit, "bool", Some(17), None, Some(3));
        assert!(
            result.is_err(),
            "Bit position 16 should be invalid for 16-bit mode"
        );

        // Testing error case: empty registers
        let empty_registers = vec![];
        let result = decode_register_value(&empty_registers, "bool", Some(1), None, Some(3));
        assert!(result.is_err());

        // Testing default bit_position (should be 1 now per Modbus convention)
        let registers = vec![0x0001]; // Only bit 1 (LSB) is set
        let result = decode_register_value(&registers, "bool", None, None, Some(3))
            .expect("decoding bool with default bit position should succeed");
        assert_eq!(result, RedisValue::Integer(1)); // Default bit 0 = 1
    }

    #[test]
    fn test_decode_register_value_other_formats() {
        // Ensure other data formats still work normally
        let registers = vec![0x1234];

        // Testing uint16
        let result = decode_register_value(&registers, "uint16", None, None, None)
            .expect("decoding uint16 should succeed");
        assert_eq!(result, RedisValue::Integer(0x1234));

        // Testing int16
        let result = decode_register_value(&registers, "int16", None, None, None)
            .expect("decoding int16 should succeed");
        assert_eq!(result, RedisValue::Integer(i64::from(0x1234_i16)));

        // Testing float32 (needs 2 registers)
        let float_registers = vec![0x4000, 0x0000]; // 2.0 in IEEE 754
        let result = decode_register_value(&float_registers, "float32", None, None, None)
            .expect("decoding float32 should succeed");
        if let RedisValue::Float(f) = result {
            assert!((f - 2.0).abs() < 0.0001);
        } else {
            panic!("Expected float value");
        }
    }

    #[test]
    fn test_reverse_logic_moved_to_data_processor() {
        // Testing reverse logic has been moved to data processing module
        // This test validates that protocol layer no longer directly processes reverse logic

        use crate::core::config::types::{ScalingInfo, TelemetryType};

        // Test case 1: Signal with reverse = true, raw value = 1 should become 0
        let raw_value = 1.0;
        let scaling = ScalingInfo {
            scale: 1.0,
            offset: 0.0,
            unit: None,
            reverse: Some(true),
        };

        let processed_value =
            data_processor::process_point_value(raw_value, &TelemetryType::Signal, Some(&scaling));

        assert_eq!(
            processed_value, 0.0,
            "Raw value 1 with reverse=true should become 0"
        );

        // Test case 2: Signal with reverse = true, raw value = 0 should become 1
        let raw_value = 0.0;
        let processed_value =
            data_processor::process_point_value(raw_value, &TelemetryType::Signal, Some(&scaling));

        assert_eq!(
            processed_value, 1.0,
            "Raw value 0 with reverse=true should become 1"
        );

        // Test case 3: Signal with reverse = false, value should not change
        let raw_value = 1.0;
        let scaling_no_reverse = ScalingInfo {
            scale: 1.0,
            offset: 0.0,
            unit: None,
            reverse: Some(false),
        };
        let processed_value = data_processor::process_point_value(
            raw_value,
            &TelemetryType::Signal,
            Some(&scaling_no_reverse),
        );

        assert_eq!(
            processed_value, 1.0,
            "Raw value 1 with reverse=false should remain 1"
        );

        // Test case 4: Telemetry type should not apply reverse logic
        let raw_value = 100.0;
        let scaling_with_scale = ScalingInfo {
            scale: 0.1,
            offset: 2.0,
            unit: Some("C".to_string()),
            reverse: Some(true), // Should be ignored
        };
        let processed_value = data_processor::process_point_value(
            raw_value,
            &TelemetryType::Telemetry,
            Some(&scaling_with_scale),
        );

        assert_eq!(
            processed_value,
            12.0, // 100 * 0.1 + 2.0 = 12.0
            "Telemetry type should apply scale/offset but ignore reverse"
        );
    }
}
