//! Comprehensive Modbus Communication Tests
//!
//! This module provides a complete test suite for Modbus communication functionality,
//! covering both client and server implementations, multiple communication modes,
//! error conditions, and performance scenarios.

use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, SystemTime};
use tokio::sync::RwLock;
use tokio::time::timeout;
use tempfile::TempDir;
use chrono::Utc;

use crate::core::protocols::modbus::client::{
    ModbusClient, ModbusClientConfig, ModbusCommunicationMode, ModbusClientStats, ModbusConnectionState
};
use crate::core::protocols::modbus::server::{
    ModbusServer, ModbusServerConfig, ModbusServerMode, ModbusServerStats
};
use crate::core::protocols::modbus::common::{
    ModbusRegisterMapping, ModbusRegisterType, ModbusDataType, ByteOrder
};
use crate::core::protocols::common::combase::{
    ComBase, PointReader, PollingPoint, ConnectionManager, ConfigValidator, 
    FourTelemetryOperations, RemoteOperationRequest, RemoteOperationType
};
use crate::core::config::config_manager::{ChannelConfig, ProtocolType, ChannelParameters};
use crate::utils::error::{ComSrvError, Result};

#[cfg(test)]
mod modbus_comprehensive_tests {
    use super::*;

    /// Create test register mappings for testing
    fn create_test_register_mappings() -> Vec<ModbusRegisterMapping> {
        vec![
            ModbusRegisterMapping {
                name: "temperature".to_string(),
                display_name: Some("Temperature Sensor".to_string()),
                register_type: ModbusRegisterType::HoldingRegister,
                address: 100,
                data_type: ModbusDataType::UInt16,
                scale: 0.1,
                offset: -40.0,
                unit: Some("°C".to_string()),
                description: Some("Temperature measurement".to_string()),
                access_mode: "read".to_string(),
                group: Some("Sensors".to_string()),
                byte_order: ByteOrder::BigEndian,
            },
            ModbusRegisterMapping {
                name: "pressure".to_string(),
                display_name: Some("Pressure Sensor".to_string()),
                register_type: ModbusRegisterType::InputRegister,
                address: 110,
                data_type: ModbusDataType::Int16,
                scale: 0.01,
                offset: 0.0,
                unit: Some("bar".to_string()),
                description: Some("Pressure measurement".to_string()),
                access_mode: "read".to_string(),
                group: Some("Sensors".to_string()),
                byte_order: ByteOrder::BigEndian,
            },
            ModbusRegisterMapping {
                name: "flow_rate".to_string(),
                display_name: Some("Flow Rate".to_string()),
                register_type: ModbusRegisterType::HoldingRegister,
                address: 120,
                data_type: ModbusDataType::Float32,
                scale: 1.0,
                offset: 0.0,
                unit: Some("L/min".to_string()),
                description: Some("Current flow rate".to_string()),
                access_mode: "read_write".to_string(),
                group: Some("Process".to_string()),
                byte_order: ByteOrder::BigEndian,
            },
            ModbusRegisterMapping {
                name: "pump_status".to_string(),
                display_name: Some("Pump Status".to_string()),
                register_type: ModbusRegisterType::Coil,
                address: 200,
                data_type: ModbusDataType::Bool,
                scale: 1.0,
                offset: 0.0,
                unit: None,
                description: Some("Pump on/off status".to_string()),
                access_mode: "read_write".to_string(),
                group: Some("Control".to_string()),
                byte_order: ByteOrder::BigEndian,
            },
            ModbusRegisterMapping {
                name: "alarm_active".to_string(),
                display_name: Some("Alarm Status".to_string()),
                register_type: ModbusRegisterType::DiscreteInput,
                address: 300,
                data_type: ModbusDataType::Bool,
                scale: 1.0,
                offset: 0.0,
                unit: None,
                description: Some("System alarm status".to_string()),
                access_mode: "read".to_string(),
                group: Some("Status".to_string()),
                byte_order: ByteOrder::BigEndian,
            },
        ]
    }

    /// Create test TCP client configuration
    fn create_test_tcp_client_config() -> ModbusClientConfig {
        ModbusClientConfig {
            mode: ModbusCommunicationMode::Tcp,
            slave_id: 1,
            timeout: Duration::from_secs(5),
            max_retries: 3,
            poll_interval: Duration::from_millis(100),
            point_mappings: create_test_register_mappings(),
            port: None,
            baud_rate: None,
            data_bits: None,
            stop_bits: None,
            parity: None,
            host: Some("127.0.0.1".to_string()),
            tcp_port: Some(15502), // Use non-standard port to avoid conflicts
        }
    }

    /// Create test RTU client configuration
    fn create_test_rtu_client_config() -> ModbusClientConfig {
        ModbusClientConfig {
            mode: ModbusCommunicationMode::Rtu,
            slave_id: 2,
            timeout: Duration::from_secs(1),
            max_retries: 3,
            poll_interval: Duration::from_millis(100),
            point_mappings: create_test_register_mappings(),
            port: Some("/tmp/modbus_test_port".to_string()),
            baud_rate: Some(9600),
            data_bits: Some(tokio_serial::DataBits::Eight),
            stop_bits: Some(tokio_serial::StopBits::One),
            parity: Some(tokio_serial::Parity::None),
            host: None,
            tcp_port: None,
        }
    }

    /// Create test TCP server configuration
    fn create_test_tcp_server_config() -> ModbusServerConfig {
        ModbusServerConfig {
            mode: ModbusServerMode::Tcp,
            unit_id: 1,
            max_connections: Some(10),
            port: None,
            baud_rate: None,
            bind_address: Some("127.0.0.1".to_string()),
            bind_port: Some(15502),
            request_timeout: Some(Duration::from_secs(30)),
            register_mappings: create_test_register_mappings(),
        }
    }

    /// Create test channel configuration
    fn create_test_channel_config(protocol: ProtocolType) -> ChannelConfig {
        match protocol {
            ProtocolType::ModbusTcp => ChannelConfig {
                id: 1,
                name: "Test Modbus TCP Channel".to_string(),
                description: "Test channel for Modbus TCP".to_string(),
                protocol,
                parameters: ChannelParameters::ModbusTcp {
                    host: "127.0.0.1".to_string(),
                    port: 15502,
                    timeout: 5000,
                    max_retries: 3,
                    poll_rate: 100,
                    point_tables: std::collections::HashMap::new(),
                },
            },
            ProtocolType::ModbusRtu => ChannelConfig {
                id: 2,
                name: "Test Modbus RTU Channel".to_string(),
                description: "Test channel for Modbus RTU".to_string(),
                protocol,
                parameters: ChannelParameters::ModbusRtu {
                    port: "/tmp/modbus_test_port".to_string(),
                    baud_rate: 9600,
                    data_bits: 8,
                    parity: "None".to_string(),
                    stop_bits: 1,
                    timeout: 1000,
                    slave_id: 2,
                    max_retries: 3,
                    poll_rate: 100,
                },
            },
            _ => panic!("Unsupported protocol type for this test"),
        }
    }

    // ============================================================================
    // UNIT TESTS - Testing individual components
    // ============================================================================

    #[tokio::test]
    async fn test_modbus_client_creation_and_basic_functionality() {
        // Test TCP client creation
        let tcp_config = create_test_tcp_client_config();
        let tcp_client = ModbusClient::new(tcp_config.clone(), ModbusCommunicationMode::Tcp);
        assert!(tcp_client.is_ok(), "TCP client creation should succeed");
        
        let client = tcp_client.unwrap();
        assert_eq!(client.name(), "ModbusClient");
        assert_eq!(client.protocol_type(), "ModbusTCP");
        assert!(!client.is_running().await);
        assert!(!client.is_connected().await);

        // Test RTU client creation
        let rtu_config = create_test_rtu_client_config();
        let rtu_client = ModbusClient::new(rtu_config.clone(), ModbusCommunicationMode::Rtu);
        assert!(rtu_client.is_ok(), "RTU client creation should succeed");
        
        let rtu_client = rtu_client.unwrap();
        assert_eq!(rtu_client.name(), "ModbusClient");
        assert_eq!(rtu_client.protocol_type(), "ModbusRTU");
        assert!(!rtu_client.is_running().await);
        assert!(!rtu_client.is_connected().await);
    }

    #[tokio::test]
    async fn test_modbus_client_statistics() {
        let mut stats = ModbusClientStats::new();
        
        // Test initial state
        assert_eq!(stats.total_requests(), 0);
        assert_eq!(stats.successful_requests(), 0);
        assert_eq!(stats.failed_requests(), 0);
        assert_eq!(stats.communication_quality(), 100.0);
        assert_eq!(stats.avg_response_time_ms(), 0.0);

        // Test successful request statistics
        stats.update_request_stats(true, Duration::from_millis(50), None);
        assert_eq!(stats.total_requests(), 1);
        assert_eq!(stats.successful_requests(), 1);
        assert_eq!(stats.failed_requests(), 0);
        assert_eq!(stats.communication_quality(), 100.0);
        assert_eq!(stats.avg_response_time_ms(), 50.0);

        // Test failed request statistics
        stats.update_request_stats(false, Duration::from_millis(100), Some("timeout"));
        assert_eq!(stats.total_requests(), 2);
        assert_eq!(stats.successful_requests(), 1);
        assert_eq!(stats.failed_requests(), 1);
        assert_eq!(stats.timeout_requests(), 1);
        assert_eq!(stats.communication_quality(), 50.0);
        assert_eq!(stats.avg_response_time_ms(), 75.0); // (50 + 100) / 2

        // Test CRC errors
        stats.increment_crc_errors();
        assert_eq!(stats.crc_errors(), 1);

        // Test exception responses
        stats.increment_exception_responses();
        assert_eq!(stats.exception_responses(), 1);

        // Test statistics reset
        stats.reset();
        assert_eq!(stats.total_requests(), 0);
        assert_eq!(stats.successful_requests(), 0);
        assert_eq!(stats.communication_quality(), 100.0);
    }

    #[tokio::test]
    async fn test_modbus_server_creation_and_configuration() {
        let channel_config = create_test_channel_config(ProtocolType::ModbusTcp);
        let server_config = create_test_tcp_server_config();
        
        let server = ModbusServer::new(
            "TestModbusServer".to_string(),
            channel_config,
            server_config.clone(),
        );
        
        assert_eq!(server.name(), "TestModbusServer");
        assert_eq!(server.protocol_type(), "ModbusTCP");
        assert!(!server.is_running().await);
        
        let config = server.get_config();
        assert_eq!(config.mode, ModbusServerMode::Tcp);
        assert_eq!(config.unit_id, 1);
        assert_eq!(config.bind_port, Some(15502));
    }

    #[tokio::test]
    async fn test_modbus_config_conversion() {
        // Test TCP channel config conversion
        let tcp_channel_config = create_test_channel_config(ProtocolType::ModbusTcp);
        let tcp_modbus_config: ModbusClientConfig = tcp_channel_config.into();
        
        assert_eq!(tcp_modbus_config.mode, ModbusCommunicationMode::Tcp);
        assert_eq!(tcp_modbus_config.host, Some("127.0.0.1".to_string()));
        assert_eq!(tcp_modbus_config.tcp_port, Some(15502));
        assert_eq!(tcp_modbus_config.timeout, Duration::from_millis(5000));

        // Test RTU channel config conversion
        let rtu_channel_config = create_test_channel_config(ProtocolType::ModbusRtu);
        let rtu_modbus_config: ModbusClientConfig = rtu_channel_config.into();
        
        assert_eq!(rtu_modbus_config.mode, ModbusCommunicationMode::Rtu);
        assert_eq!(rtu_modbus_config.port, Some("/tmp/modbus_test_port".to_string()));
        assert_eq!(rtu_modbus_config.baud_rate, Some(9600));
        assert_eq!(rtu_modbus_config.slave_id, 2);
    }

    #[tokio::test]
    async fn test_modbus_register_mappings() {
        let mappings = create_test_register_mappings();
        assert_eq!(mappings.len(), 5);
        
        let temperature_mapping = &mappings[0];
        assert_eq!(temperature_mapping.name, "temperature");
        assert_eq!(temperature_mapping.address, 100);
        assert_eq!(temperature_mapping.register_type, ModbusRegisterType::HoldingRegister);
        assert_eq!(temperature_mapping.data_type, ModbusDataType::Uint16);
        assert_eq!(temperature_mapping.scale, Some(0.1));
        assert_eq!(temperature_mapping.offset, Some(-40.0));
        
        let pump_status_mapping = &mappings[3];
        assert_eq!(pump_status_mapping.name, "pump_status");
        assert_eq!(pump_status_mapping.register_type, ModbusRegisterType::Coil);
        assert_eq!(pump_status_mapping.data_type, ModbusDataType::Bool);
    }

    #[tokio::test]
    async fn test_modbus_client_point_operations() {
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Test point mapping lookup
        let temperature_mapping = client.find_mapping("temperature");
        assert!(temperature_mapping.is_some());
        assert_eq!(temperature_mapping.unwrap().address, 100);
        
        let nonexistent_mapping = client.find_mapping("nonexistent");
        assert!(nonexistent_mapping.is_none());
        
        // Test point reading (will fail without server, but should return structured error)
        let test_point = PollingPoint {
            id: "temp_001".to_string(),
            name: "temperature".to_string(),
            description: "Temperature sensor reading".to_string(),
            poll_rate: Duration::from_millis(100),
            quality_threshold: 1,
        };
        
        let result = client.read_point(&test_point).await;
        assert!(result.is_ok()); // Should return placeholder data
        
        let point_data = result.unwrap();
        assert_eq!(point_data.id, "temperature");
        assert_eq!(point_data.value, "0"); // Placeholder value
    }

    #[tokio::test]
    async fn test_config_validation() {
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Valid configuration should pass
        let validation_result = client.validate_config().await;
        assert!(validation_result.is_ok());
        
        // Test invalid configuration (zero retries)
        let mut invalid_config = create_test_tcp_client_config();
        invalid_config.max_retries = 0;
        let invalid_client = ModbusClient::new(invalid_config, ModbusCommunicationMode::Tcp).unwrap();
        
        let validation_result = invalid_client.validate_config().await;
        assert!(validation_result.is_err());
        assert!(matches!(validation_result.unwrap_err(), ComSrvError::ConfigError(_)));
    }

    // ============================================================================
    // INTEGRATION TESTS - Testing client-server communication
    // ============================================================================

    #[tokio::test]
    #[ignore] // Requires voltage_modbus server implementation
    async fn test_tcp_client_server_communication() {
        // This test would require a running Modbus TCP server
        // For now, we'll test the client connection attempt
        
        let config = create_test_tcp_client_config();
        let mut client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Test connection to non-existent server (should fail gracefully)
        let connection_result = timeout(Duration::from_secs(2), client.connect()).await;
        
        match connection_result {
            Ok(result) => {
                // Connection might succeed if there's a server running on the test port
                // or fail if there isn't - both are valid outcomes for this test
                println!("Connection result: {:?}", result);
            }
            Err(_) => {
                // Timeout is also acceptable - means connection attempt was made
                println!("Connection attempt timed out (expected behavior)");
            }
        }
        
        // Test statistics after connection attempt
        let stats = client.get_stats().await;
        assert!(stats.reconnect_attempts() >= 0); // Should have some attempt recorded
    }

    #[tokio::test]
    async fn test_client_lifecycle_operations() {
        let config = create_test_tcp_client_config();
        let mut client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Initial state
        assert!(!client.is_running().await);
        assert!(!client.is_connected().await);
        assert!(matches!(client.connection_state().await, crate::core::protocols::common::combase::ConnectionState::Disconnected));
        
        // Test start operation (will fail without server, but should change state)
        let start_result = client.start().await;
        // May succeed or fail depending on whether a server is running
        println!("Start result: {:?}", start_result);
        
        // Test stop operation
        let stop_result = client.stop().await;
        assert!(stop_result.is_ok());
        assert!(!client.is_running().await);
    }

    #[tokio::test]
    async fn test_batch_point_reading() {
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        let test_points = vec![
            PollingPoint {
                id: "temp_001".to_string(),
                name: "temperature".to_string(),
                description: "Temperature sensor".to_string(),
                poll_rate: Duration::from_millis(100),
                quality_threshold: 1,
            },
            PollingPoint {
                id: "press_001".to_string(),
                name: "pressure".to_string(),
                description: "Pressure sensor".to_string(),
                poll_rate: Duration::from_millis(100),
                quality_threshold: 1,
            },
            PollingPoint {
                id: "flow_001".to_string(),
                name: "flow_rate".to_string(),
                description: "Flow rate sensor".to_string(),
                poll_rate: Duration::from_millis(100),
                quality_threshold: 1,
            },
        ];
        
        let batch_result = client.read_points_batch(&test_points).await;
        assert!(batch_result.is_ok());
        
        let points_data = batch_result.unwrap();
        assert_eq!(points_data.len(), 3);
        
        // Verify each point has expected structure
        for point_data in points_data {
            assert!(!point_data.id.is_empty());
            assert!(!point_data.name.is_empty());
            assert!(!point_data.value.is_empty());
        }
    }

    // ============================================================================
    // ERROR HANDLING TESTS
    // ============================================================================

    #[tokio::test]
    async fn test_connection_error_handling() {
        // Test connection to invalid address
        let mut invalid_config = create_test_tcp_client_config();
        invalid_config.host = Some("999.999.999.999".to_string()); // Invalid IP
        invalid_config.timeout = Duration::from_millis(100); // Short timeout
        
        let mut client = ModbusClient::new(invalid_config, ModbusCommunicationMode::Tcp).unwrap();
        
        let connection_result = timeout(Duration::from_secs(2), client.connect()).await;
        
        // Should either timeout or return connection error
        match connection_result {
            Ok(result) => {
                assert!(result.is_err());
                println!("Connection failed as expected: {:?}", result.unwrap_err());
            }
            Err(_) => {
                println!("Connection attempt timed out (acceptable behavior)");
            }
        }
    }

    #[tokio::test]
    async fn test_write_operation_without_connection() {
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Attempt to write without establishing connection
        let write_result = client.write_single_register(100, 1234).await;
        assert!(write_result.is_err());
        
        match write_result.unwrap_err() {
            ComSrvError::ConnectionError(_) => {
                // Expected error type
                println!("Write operation failed with connection error (expected)");
            }
            ComSrvError::CommunicationError(_) => {
                // Also acceptable
                println!("Write operation failed with communication error (expected)");
            }
            other => panic!("Unexpected error type: {:?}", other),
        }
    }

    #[tokio::test]
    async fn test_invalid_point_operations() {
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Test reading nonexistent point
        let invalid_point = PollingPoint {
            id: "invalid_001".to_string(),
            name: "nonexistent_point".to_string(),
            description: "Invalid point".to_string(),
            poll_rate: Duration::from_millis(100),
            quality_threshold: 1,
        };
        
        let read_result = client.read_point(&invalid_point).await;
        assert!(read_result.is_err());
        
        match read_result.unwrap_err() {
            ComSrvError::ConfigError(_) => {
                println!("Read operation failed with config error (expected)");
            }
            other => panic!("Unexpected error type: {:?}", other),
        }
    }

    // ============================================================================
    // PERFORMANCE TESTS
    // ============================================================================

    #[tokio::test]
    async fn test_client_creation_performance() {
        let start_time = SystemTime::now();
        
        for _ in 0..100 {
            let config = create_test_tcp_client_config();
            let _client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        }
        
        let elapsed = start_time.elapsed().unwrap();
        println!("Created 100 clients in {:?}", elapsed);
        
        // Should be able to create 100 clients in reasonable time (less than 1 second)
        assert!(elapsed < Duration::from_secs(1));
    }

    #[tokio::test]
    async fn test_statistics_performance() {
        let mut stats = ModbusClientStats::new();
        let start_time = SystemTime::now();
        
        // Simulate 10000 requests
        for i in 0..10000 {
            let success = i % 10 != 0; // 90% success rate
            let response_time = Duration::from_millis(10 + (i % 100));
            let error_type = if success { None } else { Some("timeout") };
            
            stats.update_request_stats(success, response_time, error_type);
        }
        
        let elapsed = start_time.elapsed().unwrap();
        println!("Processed 10000 statistics updates in {:?}", elapsed);
        
        // Verify statistics are correct
        assert_eq!(stats.total_requests(), 10000);
        assert_eq!(stats.successful_requests(), 9000);
        assert_eq!(stats.failed_requests(), 1000);
        assert_eq!(stats.timeout_requests(), 1000);
        assert!((stats.communication_quality() - 90.0).abs() < 0.01);
        
        // Should process statistics quickly
        assert!(elapsed < Duration::from_millis(100));
    }

    #[tokio::test]
    async fn test_concurrent_client_operations() {
        use tokio::task::JoinSet;
        
        let mut join_set = JoinSet::new();
        
        // Create multiple clients concurrently
        for i in 0..10 {
            join_set.spawn(async move {
                let mut config = create_test_tcp_client_config();
                config.tcp_port = Some(15502 + i); // Use different ports
                
                let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp);
                assert!(client.is_ok());
                
                let client = client.unwrap();
                assert_eq!(client.name(), "ModbusClient");
                assert!(!client.is_running().await);
                
                // Test some operations
                let stats = client.get_stats().await;
                assert_eq!(stats.total_requests(), 0);
                
                i // Return the client index
            });
        }
        
        let mut completed = 0;
        while let Some(result) = join_set.join_next().await {
            assert!(result.is_ok());
            completed += 1;
        }
        
        assert_eq!(completed, 10);
        println!("Successfully created and operated 10 concurrent clients");
    }

    // ============================================================================
    // STRESS TESTS
    // ============================================================================

    #[tokio::test]
    #[ignore] // Only run with explicit request due to resource usage
    async fn test_memory_usage_under_load() {
        use std::sync::atomic::{AtomicUsize, Ordering};
        use tokio::task::JoinSet;
        
        let client_count = Arc::new(AtomicUsize::new(0));
        let mut join_set = JoinSet::new();
        
        // Create many clients to test memory usage
        for i in 0..1000 {
            let client_count = Arc::clone(&client_count);
            
            join_set.spawn(async move {
                let mut config = create_test_tcp_client_config();
                config.tcp_port = Some(15502 + (i % 100)); // Reuse some ports
                
                let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp);
                if client.is_ok() {
                    client_count.fetch_add(1, Ordering::Relaxed);
                    
                    // Hold client for a short time
                    tokio::time::sleep(Duration::from_millis(10)).await;
                }
                
                i
            });
        }
        
        // Wait for all clients to complete
        let mut completed = 0;
        while let Some(result) = join_set.join_next().await {
            if result.is_ok() {
                completed += 1;
            }
        }
        
        let final_count = client_count.load(Ordering::Relaxed);
        println!("Successfully created {} clients under load", final_count);
        assert!(final_count > 900); // Should create most clients successfully
    }

    #[tokio::test]
    async fn test_rapid_state_changes() {
        let config = create_test_tcp_client_config();
        let mut client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Perform rapid start/stop cycles
        for i in 0..10 {
            let start_result = client.start().await;
            println!("Cycle {}: Start result: {:?}", i, start_result);
            
            // Brief operation
            tokio::time::sleep(Duration::from_millis(10)).await;
            
            let stop_result = client.stop().await;
            assert!(stop_result.is_ok(), "Stop should always succeed");
            
            // Verify stopped state
            assert!(!client.is_running().await);
        }
        
        println!("Successfully completed 10 rapid start/stop cycles");
    }

    // ============================================================================
    // MOCK SERVER TESTS (when voltage_modbus server is available)
    // ============================================================================

    #[tokio::test]
    #[ignore] // Requires mock server setup
    async fn test_end_to_end_communication() {
        // This test would set up a mock Modbus server and test full communication
        // Currently ignored as it requires voltage_modbus server implementation
        
        println!("End-to-end communication test would go here");
        println!("Requires mock Modbus server implementation");
    }

    #[tokio::test]
    #[ignore] // Requires mock server setup
    async fn test_all_function_codes() {
        // Test all supported Modbus function codes
        // Would require a comprehensive mock server
        
        println!("Function code testing would include:");
        println!("- Read Coils (0x01)");
        println!("- Read Discrete Inputs (0x02)"); 
        println!("- Read Holding Registers (0x03)");
        println!("- Read Input Registers (0x04)");
        println!("- Write Single Coil (0x05)");
        println!("- Write Single Register (0x06)");
        println!("- Write Multiple Coils (0x0F)");
        println!("- Write Multiple Registers (0x10)");
    }

    // ============================================================================
    // HELPER FUNCTIONS FOR INTEGRATION WITH ACTUAL SERVERS
    // ============================================================================

    /// Start a test Modbus TCP server (mock implementation)
    #[allow(dead_code)]
    async fn start_test_tcp_server(port: u16) -> Result<tokio::task::JoinHandle<()>> {
        // This would start a real Modbus TCP server for testing
        // For now, return a dummy task
        Ok(tokio::spawn(async move {
            println!("Mock TCP server running on port {}", port);
            tokio::time::sleep(Duration::from_secs(60)).await;
        }))
    }

    /// Create test data for Modbus registers
    #[allow(dead_code)]
    fn create_test_register_data() -> HashMap<u16, u16> {
        let mut data = HashMap::new();
        data.insert(100, 2500); // Temperature: 25.0°C scaled
        data.insert(110, 150);  // Pressure: 1.5 bar scaled
        data.insert(120, 100);  // Flow rate: 10.0 L/min
        data.insert(200, 1);    // Pump status: ON
        data.insert(300, 0);    // Alarm: inactive
        data
    }

    /// Utility function to wait for server startup
    #[allow(dead_code)]
    async fn wait_for_server_ready(host: &str, port: u16, timeout: Duration) -> bool {
        let start_time = SystemTime::now();
        
        while start_time.elapsed().unwrap() < timeout {
            if tokio::net::TcpStream::connect(format!("{}:{}", host, port)).await.is_ok() {
                return true;
            }
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        
        false
    }
}

/// Integration test module for cross-component testing
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_client_server_integration_mock() {
        // Mock integration test showing how client and server would interact
        
        let client_config = create_test_tcp_client_config();
        let server_config = create_test_tcp_server_config();
        let channel_config = create_test_channel_config(ProtocolType::ModbusTcp);
        
        // Create client and server
        let client = ModbusClient::new(client_config, ModbusCommunicationMode::Tcp).unwrap();
        let server = ModbusServer::new(
            "IntegrationTestServer".to_string(),
            channel_config,
            server_config,
        );
        
        // Verify configurations are compatible
        assert_eq!(client.protocol_type(), server.protocol_type());
        
        // In a real test, we would:
        // 1. Start the server
        // 2. Connect the client
        // 3. Perform read/write operations
        // 4. Verify data consistency
        // 5. Test error conditions
        // 6. Clean up resources
        
        println!("Integration test framework established");
        println!("Client protocol: {}", client.protocol_type());
        println!("Server protocol: {}", server.protocol_type());
    }

    #[tokio::test]
    async fn test_protocol_factory_integration() {
        use crate::core::protocols::common::ProtocolFactory;
        
        let factory = ProtocolFactory::new();
        
        // Test protocol support
        assert!(factory.is_protocol_supported(&ProtocolType::ModbusTcp));
        assert!(factory.is_protocol_supported(&ProtocolType::ModbusRtu));
        
        // Test channel creation through factory
        let tcp_channel_config = create_test_channel_config(ProtocolType::ModbusTcp);
        let result = factory.create_channel(tcp_channel_config);
        
        // Should either succeed or fail gracefully
        match result {
            Ok(_) => println!("Channel created successfully through factory"),
            Err(e) => println!("Channel creation failed (expected in test environment): {}", e),
        }
    }
}

/// Performance benchmarking module
#[cfg(test)]
mod performance_benchmarks {
    use super::*;

    #[tokio::test]
    #[ignore] // Only run for performance analysis
    async fn benchmark_client_operations() {
        use std::time::Instant;
        
        let config = create_test_tcp_client_config();
        let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        
        // Benchmark client creation
        let start = Instant::now();
        for _ in 0..1000 {
            let config = create_test_tcp_client_config();
            let _client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
        }
        let creation_time = start.elapsed();
        println!("1000 client creations: {:?} ({:?} per client)", 
                creation_time, creation_time / 1000);
        
        // Benchmark statistics updates
        let mut stats = ModbusClientStats::new();
        let start = Instant::now();
        for i in 0..100000 {
            stats.update_request_stats(
                i % 10 != 0,
                Duration::from_micros(100 + (i % 1000)),
                if i % 10 == 0 { Some("timeout") } else { None }
            );
        }
        let stats_time = start.elapsed();
        println!("100000 statistics updates: {:?} ({:?} per update)", 
                stats_time, stats_time / 100000);
        
        // Benchmark point mapping lookups
        let start = Instant::now();
        for _ in 0..10000 {
            let _mapping = client.find_mapping("temperature");
        }
        let lookup_time = start.elapsed();
        println!("10000 mapping lookups: {:?} ({:?} per lookup)", 
                lookup_time, lookup_time / 10000);
    }

    #[tokio::test]
    #[ignore] // Memory intensive test
    async fn memory_usage_analysis() {
        use std::mem;
        
        // Analyze memory usage of different components
        println!("Memory usage analysis:");
        println!("ModbusClient: {} bytes", mem::size_of::<ModbusClient>());
        println!("ModbusClientConfig: {} bytes", mem::size_of::<ModbusClientConfig>());
        println!("ModbusClientStats: {} bytes", mem::size_of::<ModbusClientStats>());
        println!("ModbusRegisterMapping: {} bytes", mem::size_of::<ModbusRegisterMapping>());
        
        // Test memory growth under load
        let mut clients = Vec::new();
        let initial_memory = get_memory_usage();
        
        for i in 0..100 {
            let mut config = create_test_tcp_client_config();
            config.tcp_port = Some(15502 + i);
            let client = ModbusClient::new(config, ModbusCommunicationMode::Tcp).unwrap();
            clients.push(client);
        }
        
        let final_memory = get_memory_usage();
        println!("Memory usage: {} -> {} (+{} for 100 clients)", 
                initial_memory, final_memory, final_memory - initial_memory);
        
        // Keep clients alive to measure steady-state memory
        tokio::time::sleep(Duration::from_millis(100)).await;
        let steady_memory = get_memory_usage();
        println!("Steady-state memory: {}", steady_memory);
    }
    
    #[cfg(target_os = "linux")]
    fn get_memory_usage() -> usize {
        use std::fs;
        if let Ok(status) = fs::read_to_string("/proc/self/status") {
            for line in status.lines() {
                if line.starts_with("VmRSS:") {
                    if let Some(kb_str) = line.split_whitespace().nth(1) {
                        if let Ok(kb) = kb_str.parse::<usize>() {
                            return kb * 1024; // Convert to bytes
                        }
                    }
                }
            }
        }
        0
    }
    
    #[cfg(not(target_os = "linux"))]
    fn get_memory_usage() -> usize {
        0 // Placeholder for non-Linux systems
    }
} 