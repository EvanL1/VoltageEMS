//! Comsrv service configuration structures

use common::serde_helpers::{deserialize_bool_flexible, deserialize_u8_default_zero};
use common::validation::CsvFields;
use common::{
    ApiConfig, BaseServiceConfig, ConfigValidator, LoggingConfig, RedisConfig, ValidationLevel,
    ValidationResult,
};

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use voltage_model::PointType;
use voltage_schema_macro::Schema;

#[cfg(feature = "openapi")]
use utoipa::ToSchema;

/// Default API configuration for comsrv (port 6001)
fn default_comsrv_api() -> ApiConfig {
    ApiConfig {
        host: "0.0.0.0".to_string(),
        port: 6001,
    }
}

/// Comsrv service configuration (internal config, not exposed via API)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComsrvConfig {
    /// Base service configuration
    #[serde(flatten, default)]
    pub service: BaseServiceConfig,

    /// API configuration (has default value)
    #[serde(default = "default_comsrv_api")]
    pub api: ApiConfig,

    /// Redis configuration
    #[serde(default)]
    pub redis: RedisConfig,

    /// Logging configuration
    #[serde(default)]
    pub logging: LoggingConfig,

    /// Channel configurations
    #[serde(default)]
    pub channels: Vec<ChannelConfig>,
}

// ============================================================================
// Database Schema Definitions (re-exported from common)
// ============================================================================

/// Service configuration table SQL (from common)
pub use common::SERVICE_CONFIG_TABLE;

/// Sync metadata table SQL (from common)
pub use common::SYNC_METADATA_TABLE;

/// Default port for comsrv service
pub const DEFAULT_PORT: u16 = 6001;

/// Channel core fields (shared between Config and API responses)
/// These fields represent the essential channel identity and state
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct ChannelCore {
    /// Channel ID
    pub id: u32,

    /// Channel name
    pub name: String,

    /// Channel description
    pub description: Option<String>,

    /// Protocol type (modbus, virtual, grpc, etc.)
    pub protocol: String,

    /// Whether the channel is enabled
    #[serde(default = "common::serde_helpers::bool_true")]
    pub enabled: bool,
}

/// Channel configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct ChannelConfig {
    /// Core channel fields
    #[serde(flatten)]
    pub core: ChannelCore,

    /// Protocol-specific parameters
    #[serde(default)]
    pub parameters: HashMap<String, serde_json::Value>,

    /// Channel logging configuration
    #[serde(default)]
    pub logging: ChannelLoggingConfig,
}

impl ChannelConfig {
    /// Convenient accessor for channel ID
    pub fn id(&self) -> u32 {
        self.core.id
    }

    /// Convenient accessor for channel name
    pub fn name(&self) -> &str {
        &self.core.name
    }

    /// Convenient accessor for protocol
    pub fn protocol(&self) -> &str {
        &self.core.protocol
    }

    /// Convenient accessor for enabled status
    pub fn is_enabled(&self) -> bool {
        self.core.enabled
    }
}

/// Channels table record
/// Stores channel configurations - Maps to ChannelConfig structure
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "channels")]
struct ChannelRecord {
    #[column(primary_key)]
    channel_id: u32,

    #[column(not_null, unique)]
    name: String,

    protocol: Option<String>,

    #[column(default = "true")]
    enabled: bool,

    config: Option<String>, // JSON TEXT

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

/// Channels table SQL (generated by Schema macro)
pub const CHANNELS_TABLE: &str = ChannelRecord::CREATE_TABLE_SQL;

/// Channel-specific logging configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct ChannelLoggingConfig {
    /// Whether logging is enabled for this channel
    #[serde(default)]
    pub enabled: bool,

    /// Log level for this channel
    pub level: Option<String>,

    /// Log file for this channel
    pub file: Option<String>,
}

/// Base point configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct Point {
    /// Point ID
    pub point_id: u32,

    /// Signal name
    pub signal_name: String,

    /// Point description
    pub description: Option<String>,

    /// Unit of measurement
    pub unit: Option<String>,

    /// Protocol-specific mapping data as JSON string
    /// Contains protocol-dependent fields like slave_id, register_address for Modbus
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub protocol_mappings: Option<String>,
}

// Serde default/deserialize functions - delegate to common::serde_helpers
use common::serde_helpers::{scale_one, step_one};

fn deserialize_scale<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    common::serde_helpers::deserialize_scale(deserializer)
}

fn deserialize_offset<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    common::serde_helpers::deserialize_offset(deserializer)
}

/// Telemetry point (T)
/// For analog measurements like voltage, current, temperature
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct TelemetryPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Scale factor for value conversion
    #[serde(default = "scale_one", deserialize_with = "deserialize_scale")]
    pub scale: f64,

    /// Offset for value conversion
    #[serde(default, deserialize_with = "deserialize_offset")]
    pub offset: f64,

    /// Data type (float32, float64, int16, int32, etc.)
    #[serde(default = "default_data_type")]
    pub data_type: String,

    /// Whether to reverse signal logic (not used for telemetry values)
    /// Note: Byte order/endian for multi-byte values is controlled via protocol mappings
    /// using the `byte_order` field, not this flag.
    /// Supports: 1/0, true/false, yes/no in CSV files
    #[serde(default, deserialize_with = "deserialize_bool_flexible")]
    pub reverse: bool,
}

/// Signal point (S)
/// For digital/binary status like on/off, open/close
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct SignalPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Whether to reverse the signal logic
    /// Supports: 1/0, true/false, yes/no in CSV files
    #[serde(default, deserialize_with = "deserialize_bool_flexible")]
    pub reverse: bool,
}

/// Control point (C)
/// For remote control commands
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct ControlPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Whether to reverse the control logic (like SignalPoint)
    /// Supports: 1/0, true/false, yes/no in CSV files
    #[serde(default, deserialize_with = "deserialize_bool_flexible")]
    pub reverse: bool,

    /// Control type (momentary, latching, etc.)
    #[serde(default = "default_control_type")]
    pub control_type: String,

    /// Control value for ON/OPEN command
    #[serde(default = "default_on_value")]
    pub on_value: u16,

    /// Control value for OFF/CLOSE command
    #[serde(default)]
    pub off_value: u16,

    /// Pulse duration in milliseconds (for momentary controls)
    pub pulse_duration_ms: Option<u32>,
}

/// Adjustment point (A)
/// For remote setpoint adjustments
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct AdjustmentPoint {
    /// Base point information
    #[serde(flatten)]
    pub base: Point,

    /// Minimum allowed value
    pub min_value: Option<f64>,

    /// Maximum allowed value
    pub max_value: Option<f64>,

    /// Step size for adjustments
    #[serde(default = "step_one")]
    pub step: f64,

    /// Data type (float32, float64, int16, int32, etc.)
    #[serde(default = "default_data_type")]
    pub data_type: String,

    /// Scale factor for value conversion
    #[serde(default = "scale_one", deserialize_with = "deserialize_scale")]
    pub scale: f64,

    /// Offset for value conversion
    #[serde(default, deserialize_with = "deserialize_offset")]
    pub offset: f64,
}

/// Telemetry points table record
/// Stores analog measurement points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "telemetry_points",
    suffix = "PRIMARY KEY (channel_id, point_id)"
)]
struct TelemetryPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u32,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Signal points table record
/// Stores digital/binary status points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "signal_points", suffix = "PRIMARY KEY (channel_id, point_id)")]
struct SignalPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u32,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    #[column(default = "0")]
    normal_state: i32,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Control points table record
/// Stores remote control command points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(name = "control_points", suffix = "PRIMARY KEY (channel_id, point_id)")]
struct ControlPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u32,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Adjustment points table record
/// Stores remote setpoint adjustment points with embedded protocol mappings as JSON
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "adjustment_points",
    suffix = "PRIMARY KEY (channel_id, point_id)"
)]
struct AdjustmentPointRecord {
    #[column(not_null)]
    point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    channel_id: u32,

    #[column(not_null)]
    signal_name: String,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    unit: Option<String>,

    #[column(default = "false")]
    reverse: bool,

    data_type: Option<String>,

    description: Option<String>,

    protocol_mappings: Option<String>, // JSON TEXT
}

/// Telemetry points table SQL (generated by Schema macro)
pub const TELEMETRY_POINTS_TABLE: &str = TelemetryPointRecord::CREATE_TABLE_SQL;

/// Signal points table SQL (generated by Schema macro)
pub const SIGNAL_POINTS_TABLE: &str = SignalPointRecord::CREATE_TABLE_SQL;

/// Control points table SQL (generated by Schema macro)
pub const CONTROL_POINTS_TABLE: &str = ControlPointRecord::CREATE_TABLE_SQL;

/// Adjustment points table SQL (generated by Schema macro)
pub const ADJUSTMENT_POINTS_TABLE: &str = AdjustmentPointRecord::CREATE_TABLE_SQL;

// ────────────────────── Channel Routing Table ──────────────────────

/// Channel routing table record (C2C routing)
/// Stores direct channel-to-channel data forwarding rules
#[allow(dead_code)]
#[derive(Schema)]
#[table(
    name = "channel_routing",
    suffix = "PRIMARY KEY (source_channel_id, source_type, source_point_id)"
)]
struct ChannelRoutingRecord {
    #[column(not_null, references = "channels(channel_id)")]
    source_channel_id: u32,

    #[column(not_null)]
    source_type: String, // T/S/C/A

    #[column(not_null)]
    source_point_id: u32,

    #[column(not_null, references = "channels(channel_id)")]
    target_channel_id: u32,

    #[column(not_null)]
    target_type: String, // T/S/C/A

    #[column(not_null)]
    target_point_id: u32,

    #[column(default = "true")]
    enabled: bool,

    #[column(default = "1.0")]
    scale: f64,

    #[column(default = "0.0")]
    offset: f64,

    description: Option<String>,

    #[column(default = "CURRENT_TIMESTAMP")]
    created_at: String, // TIMESTAMP type

    #[column(default = "CURRENT_TIMESTAMP")]
    updated_at: String, // TIMESTAMP type
}

// Schema SQL constant
pub const CHANNEL_ROUTING_TABLE: &str = ChannelRoutingRecord::CREATE_TABLE_SQL;

// ============================================================================
// Protocol Mapping Structures
// ============================================================================

/// Modbus protocol mapping (corresponds to modbus_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct ModbusMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub slave_id: u8,
    pub function_code: u8,
    pub register_address: u16,
    pub data_type: String,
    pub byte_order: String,
    #[serde(default, deserialize_with = "deserialize_u8_default_zero")]
    pub bit_position: u8,
}

/// GPIO protocol mapping for DI/DO (corresponds to gpio_mappings table)
/// Direction is implicit: Signal=input, Control=output
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct GpioMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub gpio_number: u32,
}

/// Virtual protocol mapping (corresponds to virtual_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct VirtualMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub expression: Option<String>,
    #[serde(default = "default_update_interval")]
    pub update_interval: Option<u32>,
    #[serde(default)]
    pub initial_value: Option<f64>,
    #[serde(default)]
    pub noise_range: Option<f64>,
}

fn default_update_interval() -> Option<u32> {
    Some(1000)
}

/// IEC 60870-5-104 protocol mapping (corresponds to iec_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct IecMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub asdu_address: i32,
    pub object_address: i32,
    pub type_id: i32,
    #[serde(default = "default_cot")]
    pub cot: i32,
    #[serde(default)]
    pub qualifier: i32,
}

fn default_cot() -> i32 {
    20 // Default Cause of Transmission
}

/// gRPC protocol mapping (corresponds to grpc_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct GrpcMapping {
    #[serde(default)] // channel_id from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type from filename context
    pub telemetry_type: String,
    pub service_name: String,
    pub method_name: String,
    pub field_path: Option<String>,
}

/// CAN protocol mapping (corresponds to can_mappings table)
#[derive(Debug, Clone, Serialize, Deserialize)]
#[cfg_attr(feature = "openapi", derive(ToSchema))]
pub struct CanMapping {
    #[serde(default)] // channel_id comes from directory context
    pub channel_id: u32,
    pub point_id: u32,
    #[serde(default)] // telemetry_type comes from filename context
    pub telemetry_type: String,
    pub can_id: u32,
    #[serde(default)]
    pub msg_name: Option<String>,
    #[serde(default)]
    pub signal_name: Option<String>,
    pub start_bit: u32,  // Changed to u32 to match database
    pub bit_length: u32, // Changed to u32 to match database
    #[serde(default = "default_byte_order")]
    pub byte_order: String,
    #[serde(default = "default_data_type")]
    pub data_type: String,
    #[serde(default)]
    pub signed: bool,
    #[serde(default = "scale_one")]
    pub scale: f64,
    #[serde(default)]
    pub offset: f64,
    #[serde(default)]
    pub min_value: Option<f64>,
    #[serde(default)]
    pub max_value: Option<f64>,
    #[serde(default)]
    pub unit: Option<String>,
}

// Default value functions for serde
fn default_byte_order() -> String {
    "ABCD".to_string()
}

fn default_data_type() -> String {
    "uint32".to_string()
}

// ============================================================================
// Database Insertion Support - Automated binding through trait
// ============================================================================

use sqlx::{sqlite::SqliteQueryResult, Executor, Sqlite};

/// Trait for inserting point definitions into database
#[allow(async_fn_in_trait)]
pub trait SqlInsertablePoint {
    /// Execute insertion with automatic parameter binding for points
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u32,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>;
}

// ============================================================================
// Runtime Configuration Structure
// ============================================================================

/// Complete runtime channel configuration
/// Contains base configuration and points with embedded protocol mappings
#[derive(Debug, Clone)]
pub struct RuntimeChannelConfig {
    /// Base channel configuration (Arc-wrapped for zero-copy sharing)
    pub base: Arc<ChannelConfig>,

    /// Telemetry points (with embedded protocol_mappings JSON)
    pub telemetry_points: Vec<TelemetryPoint>,

    /// Signal points (with embedded protocol_mappings JSON)
    pub signal_points: Vec<SignalPoint>,

    /// Control points (with embedded protocol_mappings JSON)
    pub control_points: Vec<ControlPoint>,

    /// Adjustment points (with embedded protocol_mappings JSON)
    pub adjustment_points: Vec<AdjustmentPoint>,
    // Protocol mappings are now embedded in each point's protocol_mappings field
}

impl RuntimeChannelConfig {
    /// Create from base configuration (wraps in Arc for zero-copy sharing)
    pub fn from_base(base: ChannelConfig) -> Self {
        Self::from_base_arc(Arc::new(base))
    }

    /// Create from Arc-wrapped base configuration (zero-copy)
    pub fn from_base_arc(base: Arc<ChannelConfig>) -> Self {
        Self {
            base,
            telemetry_points: Vec::new(),
            signal_points: Vec::new(),
            control_points: Vec::new(),
            adjustment_points: Vec::new(),
        }
    }

    /// Get channel ID
    pub fn id(&self) -> u32 {
        self.base.core.id
    }

    /// Get channel name
    pub fn name(&self) -> &str {
        &self.base.core.name
    }

    /// Get protocol
    pub fn protocol(&self) -> &str {
        &self.base.core.protocol
    }

    /// Check if enabled
    pub fn is_enabled(&self) -> bool {
        self.base.core.enabled
    }

    // ========================================================================
    // Point Query Methods (Type-Safe)
    // ========================================================================
    //
    // DESIGN PRINCIPLE: point_id is only unique within a point type.
    // The composite key is (channel_id, point_type, point_id).
    //
    // When querying points, you MUST either:
    // 1. Iterate over a specific type collection (e.g., `for pt in &signal_points`)
    // 2. Use typed query methods (e.g., `get_control_point(id)`)
    //
    // NEVER search across all point types with just a point_id - this was the
    // root cause of the GPIO mapping bug where signal and control had the same
    // point_id but different GPIO numbers.
    // ========================================================================

    /// Get a telemetry point by ID
    pub fn get_telemetry_point(&self, point_id: u32) -> Option<&TelemetryPoint> {
        self.telemetry_points
            .iter()
            .find(|p| p.base.point_id == point_id)
    }

    /// Get a signal point by ID
    pub fn get_signal_point(&self, point_id: u32) -> Option<&SignalPoint> {
        self.signal_points
            .iter()
            .find(|p| p.base.point_id == point_id)
    }

    /// Get a control point by ID
    pub fn get_control_point(&self, point_id: u32) -> Option<&ControlPoint> {
        self.control_points
            .iter()
            .find(|p| p.base.point_id == point_id)
    }

    /// Get an adjustment point by ID
    pub fn get_adjustment_point(&self, point_id: u32) -> Option<&AdjustmentPoint> {
        self.adjustment_points
            .iter()
            .find(|p| p.base.point_id == point_id)
    }

    /// Get a point's base info by type and ID
    ///
    /// This is the type-safe way to query a point when you have the type information.
    /// The caller must provide the point_type to avoid cross-type search bugs.
    pub fn get_point_by_type(&self, point_type: PointType, point_id: u32) -> Option<&Point> {
        match point_type {
            PointType::Telemetry => self.get_telemetry_point(point_id).map(|p| &p.base),
            PointType::Signal => self.get_signal_point(point_id).map(|p| &p.base),
            PointType::Control => self.get_control_point(point_id).map(|p| &p.base),
            PointType::Adjustment => self.get_adjustment_point(point_id).map(|p| &p.base),
        }
    }
}

// Default value functions
fn default_control_type() -> String {
    "momentary".to_string()
}

fn default_on_value() -> u16 {
    1
}

// Default implementations
impl Default for ComsrvConfig {
    fn default() -> Self {
        let service = BaseServiceConfig {
            name: "comsrv".to_string(),
            ..Default::default()
        };

        let api = ApiConfig {
            host: "0.0.0.0".to_string(),
            port: 6001, // comsrv default port
        };

        Self {
            service,
            api,
            redis: RedisConfig::default(),
            logging: LoggingConfig::default(),
            channels: Vec::new(),
        }
    }
}

// ============================================================================
// Validation implementations
// ============================================================================

use anyhow::Result;

impl ConfigValidator for ComsrvConfig {
    fn validate_syntax(&self) -> Result<ValidationResult> {
        // Syntax validation is mainly done during deserialization
        // If we get here, the YAML/JSON was parseable
        Ok(ValidationResult::new(ValidationLevel::Syntax))
    }

    fn validate_schema(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Schema);

        // Validate common components
        self.service.validate(&mut result);
        self.api.validate(&mut result);
        self.redis.validate(&mut result);
        self.logging.validate(&mut result);

        // Validate that at least one channel is configured
        if self.channels.is_empty() {
            result.add_error("Configuration must include at least one channel".to_string());
        }

        // Validate channels
        for (idx, channel) in self.channels.iter().enumerate() {
            channel.validate(&mut result, idx);
        }

        Ok(result)
    }

    fn validate_business(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Business);

        // Check for duplicate channel IDs
        let mut channel_ids = std::collections::HashSet::new();
        for channel in &self.channels {
            if !channel_ids.insert(channel.core.id) {
                result.add_error(format!("Duplicate channel ID: {}", channel.core.id));
            }
        }

        // Check for duplicate channel names
        let mut channel_names = std::collections::HashSet::new();
        for channel in &self.channels {
            if !channel_names.insert(&channel.core.name) {
                result.add_error(format!("Duplicate channel name: {}", channel.core.name));
            }
        }

        // Warn if no channels configured
        if self.channels.is_empty() {
            result.add_warning("No channels configured".to_string());
        }

        // Check if protocol is supported
        let supported_protocols = ["modbus_tcp", "modbus_rtu", "virtual", "grpc"];
        for channel in &self.channels {
            if !supported_protocols.contains(&channel.core.protocol.as_str()) {
                result.add_warning(format!(
                    "Channel {} uses unknown protocol: {}",
                    channel.core.name, channel.core.protocol
                ));
            }
        }

        Ok(result)
    }

    fn validate_runtime(&self) -> Result<ValidationResult> {
        let mut result = ValidationResult::new(ValidationLevel::Runtime);

        // Port availability check
        self.api.validate_runtime(&mut result);

        // Redis connectivity would be checked here if needed
        // (async function would need to be called separately)

        Ok(result)
    }
}

impl ChannelConfig {
    /// Validate channel configuration
    pub fn validate(&self, result: &mut ValidationResult, idx: usize) {
        if self.core.name.is_empty() {
            result.add_error(format!("Channel {} name cannot be empty", idx));
        }

        if self.core.protocol.is_empty() {
            result.add_error(format!(
                "Channel {} protocol cannot be empty",
                self.core.name
            ));
        }

        // Protocol-specific parameter validation
        match self.core.protocol.as_str() {
            "modbus_tcp" => {
                if !self.parameters.contains_key("host") {
                    result.add_error(format!(
                        "Channel {}: Modbus TCP requires 'host' parameter",
                        self.core.name
                    ));
                }
                if !self.parameters.contains_key("port") {
                    result.add_error(format!(
                        "Channel {}: Modbus TCP requires 'port' parameter",
                        self.core.name
                    ));
                }
            },
            "modbus_rtu" => {
                if !self.parameters.contains_key("device") {
                    result.add_error(format!(
                        "Channel {}: Modbus RTU requires 'device' parameter",
                        self.core.name
                    ));
                }
                if !self.parameters.contains_key("baud_rate") {
                    result.add_error(format!(
                        "Channel {}: Modbus RTU requires 'baud_rate' parameter",
                        self.core.name
                    ));
                }
            },
            _ => {
                // Other protocols may have different requirements
            },
        }
    }
}

/// Type alias for backward compatibility - use GenericValidator directly for new code
pub type ComsrvValidator = common::GenericValidator<ComsrvConfig>;

// ============================================================================
// Centralized Configuration Constants for Comsrv
// ============================================================================

/// Redis key patterns for comsrv data storage and command queues
pub struct ChannelRedisKeys;

impl ChannelRedisKeys {
    /// Channel data storage key pattern: "comsrv:{channel_id}:{point_type}"
    /// point_type: T (telemetry), S (signal), C (control), A (adjustment)
    pub const CHANNEL_DATA: &'static str = "comsrv:{}:{}";

    /// Control command TODO queue: "comsrv:{channel_id}:C:TODO"
    pub const CONTROL_TODO: &'static str = "comsrv:{}:C:TODO";

    /// Adjustment command TODO queue: "comsrv:{channel_id}:A:TODO"
    pub const ADJUSTMENT_TODO: &'static str = "comsrv:{}:A:TODO";

    /// Helper method to format channel data key
    pub fn channel_data(channel_id: u32, point_type: &str) -> String {
        format!("comsrv:{}:{}", channel_id, point_type)
    }

    /// Helper method to format control TODO key
    pub fn control_todo(channel_id: u32) -> String {
        format!("comsrv:{}:C:TODO", channel_id)
    }

    /// Helper method to format adjustment TODO key
    pub fn adjustment_todo(channel_id: u32) -> String {
        format!("comsrv:{}:A:TODO", channel_id)
    }

    /// Helper method to format channel point data key: "comsrv:{channel_id}:{type}:{point_id}"
    /// Used for storing individual point values within a channel
    pub fn channel_point_data(channel_id: u32, point_type: &str, point_id: u32) -> String {
        format!("comsrv:{}:{}:{}", channel_id, point_type, point_id)
    }

    /// Helper method to format channel timestamp key: "comsrv:{channel_id}:{type}:ts"
    /// Used for storing timestamp of last update for a channel data type
    pub fn channel_timestamp(channel_id: u32, point_type: &str) -> String {
        format!("comsrv:{}:{}:ts", channel_id, point_type)
    }

    /// Helper method to format channel raw data key: "comsrv:{channel_id}:{type}:raw"
    /// Used for storing raw/unprocessed data before transformation
    pub fn channel_raw_data(channel_id: u32, point_type: &str) -> String {
        format!("comsrv:{}:{}:raw", channel_id, point_type)
    }
}

/// Database table names for comsrv
pub struct TableNames;

impl TableNames {
    pub const POINTS: &'static str = "points";
    pub const MODBUS_MAPPINGS: &'static str = "modbus_mappings";
    pub const CAN_MAPPINGS: &'static str = "can_mappings";
    pub const VIRTUAL_MAPPINGS: &'static str = "virtual_mappings";
    pub const IEC_MAPPINGS: &'static str = "iec_mappings";
    pub const GRPC_MAPPINGS: &'static str = "grpc_mappings";
    pub const CHANNELS: &'static str = "channels";
    pub const SERVICE_CONFIG: &'static str = "service_config";
    pub const SYNC_METADATA: &'static str = "sync_metadata";
}

/// Configuration file keys for comsrv
pub struct ConfigKeys;

impl ConfigKeys {
    pub const CAN_MAPPINGS: &'static str = "can_mappings";
    pub const MODBUS_MAPPINGS: &'static str = "modbus_mappings";
    pub const VIRTUAL_MAPPINGS: &'static str = "virtual_mappings";
    pub const IEC_MAPPINGS: &'static str = "iec_mappings";
    pub const GRPC_MAPPINGS: &'static str = "grpc_mappings";
}

// ============================================================================
// Centralized SQL Queries for Protocol Plugins
// ============================================================================

/// Protocol-specific SQL queries
pub struct ProtocolQueries;

impl ProtocolQueries {
    /// CAN protocol point query with mappings
    pub const CAN_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.can_id, m.msg_name,
            m.start_bit, m.bit_length, m.byte_order,
            m.signed, m.min_value, m.max_value
        FROM points p
        LEFT JOIN can_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
    "#;

    /// Modbus TCP protocol point query with mappings
    pub const MODBUS_TCP_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.slave_id, m.function_code, m.register_address,
            m.data_type as modbus_data_type, m.byte_order, m.bit_position
        FROM points p
        LEFT JOIN modbus_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
        ORDER BY m.slave_id, m.function_code, m.register_address
    "#;

    /// Modbus RTU points query
    ///
    /// Uses the same query structure as Modbus TCP since both protocols
    /// share the same application layer. The only difference is the
    /// transport layer (TCP vs serial RTU).
    pub const MODBUS_RTU_POINTS: &'static str = Self::MODBUS_TCP_POINTS;

    /// Virtual protocol point query with mappings
    pub const VIRTUAL_POINTS: &'static str = r#"
        SELECT
            p.point_id, p.signal_name, p.telemetry_type,
            p.scale, p.offset, p.unit, p.reverse, p.data_type,
            m.simulation_type, m.min_value, m.max_value,
            m.frequency, m.amplitude, m.noise_level,
            m.initial_value, m.step
        FROM points p
        LEFT JOIN virtual_mappings m ON p.point_id = m.point_id
            AND p.channel_id = m.channel_id
            AND p.telemetry_type = m.telemetry_type
        WHERE p.channel_id = ?
    "#;
}

// ============================================================================
// SqlInsertablePoint implementations for Point types
// ============================================================================

impl SqlInsertablePoint for TelemetryPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u32,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'T', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(self.scale)
        .bind(self.offset)
        .bind(&self.base.unit)
        .bind(self.reverse)
        .bind(&self.data_type)
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

impl SqlInsertablePoint for SignalPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u32,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'S', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(1.0) // Scale default for signal
        .bind(0.0) // Offset default for signal
        .bind(&self.base.unit)
        .bind(self.reverse) // Use actual reverse value from SignalPoint
        .bind("uint16") // Data type default for signal
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

impl SqlInsertablePoint for ControlPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u32,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'C', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(1.0) // Scale default for control
        .bind(0.0) // Offset default for control
        .bind(&self.base.unit)
        .bind(self.reverse) // Use configured reverse value
        .bind("uint16") // Data type default for control
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

impl SqlInsertablePoint for AdjustmentPoint {
    async fn insert_with<'e, E>(
        &self,
        executor: E,
        channel_id: u32,
    ) -> Result<SqliteQueryResult, sqlx::Error>
    where
        E: Executor<'e, Database = Sqlite>,
    {
        sqlx::query(
            r#"
            INSERT INTO points (channel_id, point_id, telemetry_type, signal_name,
                               scale, offset, unit, reverse, data_type, description)
            VALUES (?, ?, 'A', ?, ?, ?, ?, ?, ?, ?)
            "#,
        )
        .bind(channel_id)
        .bind(self.base.point_id)
        .bind(&self.base.signal_name)
        .bind(self.scale)
        .bind(self.offset)
        .bind(&self.base.unit)
        .bind(false) // Reverse default for adjustment
        .bind(&self.data_type)
        .bind(&self.base.description)
        .execute(executor)
        .await
    }
}

// ============================================================================
// CSV Header Validation - CsvFields Trait Implementations
// ============================================================================

impl CsvFields for TelemetryPoint {
    fn field_names() -> Vec<String> {
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for SignalPoint {
    fn field_names() -> Vec<String> {
        // Signal points use the same CSV format as telemetry
        // The 'reverse' field serves as signal logic inversion
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for ControlPoint {
    fn field_names() -> Vec<String> {
        // Control points use the same basic CSV format
        // Additional fields (control_type, on_value, etc.) have defaults
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

impl CsvFields for AdjustmentPoint {
    fn field_names() -> Vec<String> {
        // Adjustment points use the same basic CSV format
        // Additional fields (min_value, max_value, step) have defaults
        vec![
            "point_id".to_string(),
            "signal_name".to_string(),
            "scale".to_string(),
            "offset".to_string(),
            "unit".to_string(),
            "reverse".to_string(),
            "data_type".to_string(),
        ]
    }
}

#[cfg(test)]
#[allow(clippy::disallowed_methods)] // Test code - unwrap is acceptable
mod tests {
    use super::*;

    #[test]
    fn test_minimal_config_with_only_channels() {
        let yaml = r#"
channels:
  - id: 1001
    name: "Test Channel"
    protocol: "modbus_tcp"
    enabled: true
    parameters:
      host: "192.168.1.100"
      port: 502
    logging:
      enabled: false
"#;

        let config: ComsrvConfig =
            serde_yaml::from_str(yaml).expect("Should load minimal config with only channels");

        // Verify default values are used
        assert_eq!(config.service.name, "unnamed_service");
        assert_eq!(config.api.host, "0.0.0.0");
        assert_eq!(config.api.port, 6001);
        // Redis URL can be localhost or 127.0.0.1 depending on environment
        assert!(
            config.redis.url == "redis://127.0.0.1:6379"
                || config.redis.url == "redis://localhost:6379",
            "Unexpected redis.url: {}",
            config.redis.url
        );
        assert_eq!(config.channels.len(), 1);
        assert_eq!(config.channels[0].core.name, "Test Channel");
    }

    #[test]
    fn test_empty_config_uses_all_defaults() {
        let yaml = "{}";

        let config: ComsrvConfig =
            serde_yaml::from_str(yaml).expect("Should load empty config with all defaults");

        // Verify all default values
        assert_eq!(config.service.name, "unnamed_service");
        assert_eq!(config.api.host, "0.0.0.0");
        assert_eq!(config.api.port, 6001);
        // Redis URL can be localhost or 127.0.0.1 depending on environment
        assert!(
            config.redis.url == "redis://127.0.0.1:6379"
                || config.redis.url == "redis://localhost:6379",
            "Unexpected redis.url: {}",
            config.redis.url
        );
        assert_eq!(config.channels.len(), 0);
    }
}
