# VoltageEMS Lua架构提案

## 概述

基于Lua规则引擎的成功实现，我们可以考虑将更多服务迁移到Lua实现，以简化系统架构、提高性能、降低部署复杂度。

## 服务分析

### 1. rulesrv - 规则服务 ✅ 非常适合

**现状**：
- Rust实现，包含条件评估和动作执行
- 存在bug（点号键名处理问题）
- 需要独立进程和网络通信

**Lua实现优势**：
- ✅ 完全在Redis内部执行，无网络开销
- ✅ 原子性操作，避免并发问题
- ✅ 已验证可行，解决了现有bug
- ✅ 性能提升显著

**新架构**：
```
rulesrv (轻量级Rust服务)
  ├── 规则管理API（创建/更新/删除规则）
  ├── 规则模板管理
  └── 调用Redis Functions执行规则

Redis Functions
  ├── rule_execute - 执行单个规则
  ├── rules_batch_execute - 批量执行
  ├── rule_evaluate_conditions - 条件评估
  └── rule_execute_actions - 动作执行
```

### 2. modsrv - 模型服务 ✅ 适合

**现状**：
- 管理模型实例和映射关系
- 主要是CRUD操作和数据转换
- 模板管理功能

**Lua实现可行性**：
- ✅ 模型映射主要是数据结构转换
- ✅ CRUD操作适合在Redis内部完成
- ✅ 模板实例化是简单的数据复制和修改

**建议架构**：
```
modsrv (极简Rust服务)
  ├── 模板文件管理（文件系统操作）
  └── API网关

Redis Functions
  ├── model_create - 创建模型实例
  ├── model_apply_template - 应用模板
  ├── model_get_value - 获取模型值（带映射）
  ├── model_set_value - 设置模型值（带映射）
  └── model_batch_sync - 批量同步数据
```

### 3. alarmsrv - 告警服务 ⚠️ 部分适合

**现状**：
- 告警生成、确认、抑制
- 复杂的状态机管理
- 需要持久化和历史记录

**Lua实现挑战**：
- ⚠️ 状态机逻辑较复杂
- ⚠️ 需要时间序列处理
- ✅ 告警条件评估适合Lua

**混合方案**：
```
alarmsrv (Rust服务)
  ├── 告警管理API
  ├── 历史记录管理
  └── 复杂业务逻辑

Redis Functions
  ├── alarm_check_conditions - 检查告警条件
  ├── alarm_quick_create - 快速创建告警
  └── alarm_update_state - 更新告警状态
```

### 4. hissrv - 历史服务 ❌ 不适合

**原因**：
- 需要与InfluxDB交互
- 大量时序数据处理
- 复杂的查询和聚合

### 5. comsrv - 通信服务 ❌ 不适合

**原因**：
- 需要网络通信（Modbus、TCP等）
- 插件架构需要动态加载
- 实时性要求高

### 6. netsrv - 网络服务 ⚠️ 部分适合

**可以Lua化的部分**：
- 数据路由规则
- 简单的数据转换
- 队列管理

## 实施计划

### 第一阶段：rulesrv完全Lua化

1. **保留最小Rust服务**：
   - 提供REST API
   - 管理规则文件
   - 健康检查

2. **核心逻辑迁移到Lua**：
   - 规则执行引擎
   - 条件评估器
   - 动作执行器

3. **新增功能**：
   - 规则链（DAG执行）
   - 复杂事件处理（CEP）
   - 规则性能监控

### 第二阶段：modsrv部分Lua化

1. **数据映射层**：
   - 模型值读写
   - 批量数据同步
   - 映射关系管理

2. **保留Rust部分**：
   - 模板文件管理
   - WebSocket推送
   - API服务

### 第三阶段：优化其他服务

1. **alarmsrv优化**：
   - 告警条件检查Lua化
   - 快速告警生成

2. **netsrv优化**：
   - 路由规则Lua化
   - 数据转换Lua化

## 性能对比

| 操作类型 | Rust实现 | Lua实现 | 性能提升 |
|---------|----------|---------|----------|
| 规则执行 | ~15ms | ~1ms | 15x |
| 条件评估 | ~5ms | <1ms | >5x |
| 数据映射 | ~3ms | <1ms | >3x |
| 批量操作 | O(n) | O(1) | 显著 |

## 架构优势

1. **简化部署**：
   - 减少独立服务数量
   - 降低资源消耗
   - 简化运维

2. **提高性能**：
   - 无网络开销
   - 原子操作
   - 更好的缓存利用

3. **增强可靠性**：
   - 减少故障点
   - 简化错误处理
   - 更好的事务支持

4. **开发效率**：
   - Lua脚本热更新
   - 更快的迭代速度
   - 更简单的调试

## 风险与挑战

1. **Lua限制**：
   - 不能进行网络IO
   - 不能访问文件系统
   - 计算密集型任务性能有限

2. **调试困难**：
   - 需要良好的日志记录
   - 错误处理需要特别注意

3. **版本管理**：
   - Lua脚本版本控制
   - 向后兼容性

## 结论

建议按以下优先级实施：

1. **立即实施**：rulesrv完全Lua化
2. **近期实施**：modsrv数据层Lua化
3. **评估后实施**：alarmsrv和netsrv部分功能Lua化
4. **保持现状**：comsrv和hissrv继续使用Rust

这样的架构将大大简化系统，提高性能，同时保持必要的灵活性。