use anyhow::{Context, Result};
use colored::Colorize;
use std::path::Path;
use std::fs;

/// Execute the generate command
pub async fn execute(service: &str, output: &Path, format: &str, with_comments: bool) -> Result<()> {
    println!("ðŸ”§ {} default configuration for service: {}", "Generating".bold(), service.cyan());
    println!("ðŸ“„ Output file: {}", output.display());
    println!("ðŸ“‹ Format: {}", format);
    println!();

    // Generate configuration based on service type
    let yaml_content = match service {
        "alarmsrv" => generate_alarmsrv_config(),
        "hissrv" => generate_hissrv_config(),
        "comsrv" => generate_comsrv_config(),
        "modsrv" => generate_modsrv_config(),
        "netsrv" => generate_netsrv_config(),
        _ => anyhow::bail!("Unknown service: {}. Valid services are: alarmsrv, hissrv, comsrv, modsrv, netsrv", service),
    };

    // Convert to requested format
    let output_content = convert_format(&yaml_content, format, with_comments)?;

    // Create parent directories if needed
    if let Some(parent) = output.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }

    // Write to file
    fs::write(output, &output_content)
        .with_context(|| format!("Failed to write file: {}", output.display()))?;

    println!("{} Configuration file generated successfully!", "âœ…".green());
    
    if with_comments {
        println!();
        println!("{}", "â„¹ï¸  The generated file includes comments explaining each configuration option.".blue());
    }

    Ok(())
}

/// Convert YAML content to requested format
fn convert_format(yaml_content: &str, format: &str, with_comments: bool) -> Result<String> {
    match format {
        "yaml" | "yml" => {
            if with_comments {
                Ok(add_yaml_comments(yaml_content))
            } else {
                Ok(yaml_content.to_string())
            }
        }
        "json" => {
            let value: serde_yaml::Value = serde_yaml::from_str(yaml_content)?;
            let json = serde_json::to_string_pretty(&value)?;
            Ok(json)
        }
        "toml" => {
            let value: serde_yaml::Value = serde_yaml::from_str(yaml_content)?;
            let toml_value: toml::Value = serde_json::from_value(serde_json::to_value(value)?)?;
            let toml = toml::to_string_pretty(&toml_value)?;
            Ok(toml)
        }
        _ => anyhow::bail!("Unsupported format: {}. Valid formats are: yaml, json, toml", format),
    }
}

/// Add comments to YAML content
fn add_yaml_comments(yaml: &str) -> String {
    let mut result = String::new();
    
    // Add header comment
    result.push_str("# VoltageEMS Service Configuration\n");
    result.push_str("# Generated by voltage-config CLI\n");
    result.push_str("# \n");
    result.push_str("# This file contains the default configuration for the service.\n");
    result.push_str("# Modify values as needed for your environment.\n");
    result.push_str("\n");

    // Process each line and add inline comments
    for line in yaml.lines() {
        result.push_str(line);
        
        // Add inline comments for specific fields
        if line.trim_start().starts_with("name:") && line.contains("service") {
            result.push_str("  # Service identifier");
        } else if line.trim_start().starts_with("url:") && line.contains("redis") {
            result.push_str("  # Redis connection URL (redis://[password@]host:port[/database])");
        } else if line.trim_start().starts_with("level:") && line.contains("info") {
            result.push_str("  # Log level: trace, debug, info, warn, error");
        } else if line.trim_start().starts_with("metrics_port:") {
            result.push_str("  # Prometheus metrics endpoint port");
        } else if line.trim_start().starts_with("pool_size:") {
            result.push_str("  # Connection pool size for Redis");
        }
        
        result.push('\n');
    }

    result
}

// Service-specific configuration generators
fn generate_alarmsrv_config() -> String {
    r#"service:
  name: alarmsrv
  version: 0.1.0
  description: Intelligent Alarm Management Service
  instance_id: alarmsrv-01

redis:
  url: redis://localhost:6379
  prefix: "voltage:alarm:"
  pool_size: 20
  database: 0

logging:
  level: info
  console: true
  file:
    path: logs/alarmsrv.log
    rotation: daily
    max_size: 100MB
    max_files: 7

monitoring:
  metrics_enabled: true
  metrics_port: 9094
  health_check_enabled: true
  health_check_port: 8095
  health_check_interval: 30

api:
  host: 0.0.0.0
  port: 8094
  workers: 4

alarm:
  classification:
    critical_threshold: 0.9
    warning_threshold: 0.7
    info_threshold: 0.5
  processing:
    enable_deduplication: true
    deduplication_window_secs: 300
    max_alarms_per_device: 1000
  notification:
    enabled: true
    channels:
      - email
      - sms
      - webhook
    rate_limit_per_hour: 100

storage:
  retention_days: 30
  auto_cleanup: true
  cleanup_interval_hours: 24
  batch_size: 100"#.to_string()
}

fn generate_hissrv_config() -> String {
    r#"service:
  name: hissrv
  version: 0.1.0
  description: Historical Data Service
  instance_id: hissrv-01

redis:
  url: redis://localhost:6379
  prefix: "voltage:his:"
  pool_size: 30
  database: 0

logging:
  level: info
  console: true
  file:
    path: logs/hissrv.log
    rotation: daily
    max_size: 100MB
    max_files: 10

monitoring:
  metrics_enabled: true
  metrics_port: 9092
  health_check_enabled: true
  health_check_port: 8093
  health_check_interval: 30

api:
  enabled: true
  host: 0.0.0.0
  port: 8092
  prefix: /api/v1
  swagger_ui: true
  cors:
    enabled: true
    origins:
      - "*"
    methods:
      - GET
      - POST
      - PUT
      - DELETE

storage:
  default: influxdb
  backends:
    influxdb:
      enabled: true
      url: http://localhost:8086
      database: hissrv_data
      username: ""
      password: ""
      retention_days: 30
      batch_size: 1000
      flush_interval: 10
    postgresql:
      enabled: false
      host: localhost
      port: 5432
      database: hissrv
      username: postgres
      password: ""
      pool_size: 10
    mongodb:
      enabled: false
      uri: mongodb://localhost:27017
      database: hissrv
      collection: data

data:
  filters:
    default_policy: store
    rules: []
  transformations: []

performance:
  worker_threads: 4
  max_concurrent_requests: 1000
  queue_size: 10000
  batch_processing: true"#.to_string()
}

fn generate_comsrv_config() -> String {
    r#"service:
  name: comsrv
  version: 0.1.0
  description: Industrial Communication Service
  instance_id: comsrv-01

redis:
  url: redis://localhost:6379
  prefix: "voltage:com:"
  pool_size: 50
  database: 0

logging:
  level: info
  console: true
  file:
    path: logs/comsrv.log
    rotation: daily
    max_size: 100MB
    max_files: 7

monitoring:
  metrics_enabled: true
  metrics_port: 9091
  health_check_enabled: true
  health_check_port: 8091
  health_check_interval: 30

api:
  enabled: true
  host: 0.0.0.0
  port: 8091
  prefix: /api/v1

default_paths:
  config_dir: config
  point_table_dir: config/point_tables

protocols:
  modbus:
    default_timeout: 1000
    max_retries: 3
    inter_frame_delay: 10
  iec104:
    t1_timeout: 15
    t2_timeout: 10
    t3_timeout: 20
    k_value: 12
    w_value: 8
  can:
    bitrate: 250000
    sample_point: 0.875
  gpio:
    polling_interval: 100
    debounce_time: 50

channels: []"#.to_string()
}

fn generate_modsrv_config() -> String {
    r#"service:
  name: modsrv
  version: 0.1.0
  description: Model Calculation Service
  instance_id: modsrv-01

redis:
  url: redis://localhost:6379
  prefix: "voltage:mod:"
  pool_size: 30
  database: 0

logging:
  level: info
  console: true
  file:
    path: logs/modsrv.log
    rotation: daily
    max_size: 100MB
    max_files: 7

monitoring:
  metrics_enabled: true
  metrics_port: 9093
  health_check_enabled: true
  health_check_port: 8094
  health_check_interval: 30

api:
  enabled: true
  host: 0.0.0.0
  port: 8093

model:
  update_interval_ms: 1000
  config_key_pattern: "voltage:model:config:*"
  data_key_pattern: "voltage:data:*"
  output_key_pattern: "voltage:model:output:*"
  templates_dir: templates
  enable_caching: true
  max_concurrent_executions: 10

control:
  operation_key_pattern: "voltage:control:operation:*"
  enabled: true
  timeout_secs: 30
  max_retries: 3

storage:
  mode: redis
  use_redis: true
  sync_interval_secs: 10
  enable_persistence: true
  persistence_dir: data/persistence"#.to_string()
}

fn generate_netsrv_config() -> String {
    r#"service:
  name: netsrv
  version: 0.1.0
  description: Network Forwarding Service
  instance_id: netsrv-01

redis:
  url: redis://localhost:6379
  prefix: "voltage:net:"
  pool_size: 20
  database: 0

logging:
  level: info
  console: true
  file:
    path: logs/netsrv.log
    rotation: daily
    max_size: 100MB
    max_files: 7

monitoring:
  metrics_enabled: true
  metrics_port: 9095
  health_check_enabled: true
  health_check_port: 8096
  health_check_interval: 30

data:
  redis_data_key: "voltage:data:*"
  redis_polling_interval_secs: 1
  enable_buffering: true
  buffer_size: 1000

networks: []"#.to_string()
}